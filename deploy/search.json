[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Development of taxonomical biomarkers for Ulva genus",
    "section": "",
    "text": "Abstract\nUlva species play important roles in coastal ecosystems and the global mariculture industry, both for direct human consumption and their potential role as efficient biofilter. However, the identification of Ulva species remains challenging due to their simple morphologies and intraspecific and interspecific overlaps between those morphological characters that are classically used for species delimitation. In addition, currently used molecular markers (ITS, rbcL, tufA) fail to reliably separate Ulva species. Phylogenies reconstructed from either the chloroplast or the mitochondrial genomes yield contrasting results. Various academic, ecological and industrial communities could benefit from a reliable, quick and cheap way to delimit Ulva species, which is currently lacking. In this study, we present a resolved Ulva species tree based on the combined information gathered from 70 chloroplast and 29 mitochondrial protein-coding genes from 49 Ulva isolates belonging to more than 15 Ulva species. We also performed a rigorous genomic comparison of all high quality Ulva organelles sequences available to confirm that genomic signatures segregate according to the species tree we reconstructed. Then, we developed a novel combinatorial approach that tested 945 unique combinations of chloroplast and mitochondrial genes (up to 10 distinct organellar genes) to identify a minimum set of organellar molecular markers necessary to resolve Ulva phylogeny at the species level (universal Ulva species markers). We suggest the combination of the following chloroplast and mitochondrial genes as the minimum set of organellar molecular markers sufficient to discriminate Ulva at the species level: psaA, psbD, cox1 and cox2. Interestingly, chloroplast markers commonly used for Ulva species delimitation (i.e.: rbcL and tufA) showed a reduced resolution power compared to psaA and psbD and resulted in a phylogenetic tree more distant to the Ulva species tree we reconstructed. We further confirmed the resolution power of the proposed universal markers by designing primers and correctly characterizing Ulva specimens for which whole organellar genomes are not available. In addition to describing a rigorous approach for species resolution in green seaweeds based on organellar markers, we provide a useful resource for researchers and conservation ecologists and promote the selection of Ulva species for mariculture applications worldwide.",
    "crumbs": [
      "Abstract"
    ]
  },
  {
    "objectID": "cp-and-mt-dataset-overview.html",
    "href": "cp-and-mt-dataset-overview.html",
    "title": "1  Ulva organellar genomes retrieval and preparation",
    "section": "",
    "text": "1.1 On this page\nBiological insights and take-home messages are at the bottom of the page at Lesson Learnt: Section 1.3.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ulva organellar genomes retrieval and preparation</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-dataset-overview.html#on-this-page",
    "href": "cp-and-mt-dataset-overview.html#on-this-page",
    "title": "1  Ulva organellar genomes retrieval and preparation",
    "section": "",
    "text": "Here we retrieve Ulva organellar genomes\nwe investigate the",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ulva organellar genomes retrieval and preparation</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-dataset-overview.html#dataset-overview",
    "href": "cp-and-mt-dataset-overview.html#dataset-overview",
    "title": "1  Ulva organellar genomes retrieval and preparation",
    "section": "1.2 Dataset overview",
    "text": "1.2 Dataset overview\n\n1.2.1 Dataset retrieval\nWe included the following species, that as for 2022 where the most comprehensive list of cp and mt complete genomes published for Ulva.\nOltmassiellopsis viridi and Pseudendoclonium akinetum were used as an outgroup to root the phylogenetic three.\n\n\n\n\n\n\nOrganellar genome sequences and gene models were retrieved from NCBI, and corrected where necessary.\n\n\n1.2.2 Gene occupancy\nThe gene matrix occupancy and gene length distribution across organellar genomes included in this study are presented below. Most selected genes are present/ nearly present in all studied sequences. In 29 selected genes for mitochondrial, there are two genes, rps3 and rps4 that are not presented in more than 10% of the 37 mt genomic sequences. For chloroplast, there are 10 out of 70 genes not presented in more than 10% of the 34 cp genomic sequences.\n\n#!/usr/bin/env R\n\n# read tables\ncp_mt_genes_occupancy = read.delim(\"./data/cp_mt_genes_occupancy.tab\")\n\n# drop last line which is uninformative\ncp_mt_genes_occupancy = head(cp_mt_genes_occupancy, -1)\n\n# format headers\ncolnames(cp_mt_genes_occupancy) = stringr::str_remove_all(colnames(cp_mt_genes_occupancy), \".aln.fa\")\ncolnames(cp_mt_genes_occupancy) = stringr::str_replace_all(colnames(cp_mt_genes_occupancy), \"X..Sequences\", \"Species\")\n\n# melt and clean\ncp_mt_genes_occupancy = reshape2::melt(cp_mt_genes_occupancy)\ncp_mt_genes_occupancy$organell = ifelse(\n  stringr::str_detect(cp_mt_genes_occupancy$variable, \"_cp_CDS_\"),\n  \"Chloroplast\",\n  \"Mitochondrion\"\n)\ncp_mt_genes_occupancy$variable = stringr::str_remove_all(cp_mt_genes_occupancy$variable, \"X02_cp_CDS_align.\")\ncp_mt_genes_occupancy$variable = stringr::str_remove_all(cp_mt_genes_occupancy$variable, \"X02_mt_CDS_align.\")\n# set different number to assign different color to mitochondrial genes\ncp_mt_genes_occupancy$value = ifelse(\n  cp_mt_genes_occupancy$value == 1 & cp_mt_genes_occupancy$organell == \"Mitochondrion\",\n  2,\n  cp_mt_genes_occupancy$value\n)\ncp_mt_genes_occupancy$value = as.character(cp_mt_genes_occupancy$value)\n\n# plot\np1 = ggplot(cp_mt_genes_occupancy) +\n  geom_tile(aes(x = variable, y = Species, fill = value), color = \"grey75\") +\n  scale_fill_manual(values = c(\"white\", \"#469d89\", \"steelblue\")) +\n  facet_grid(~organell, scales = \"free\", space = \"free_x\") +\n  labs(x = \"Genes\",\n       y = \"Species\") +\n  theme(plot.title = element_text(size = 24, hjust = 0.5),\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(), \n        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),\n        legend.position = \"none\",\n        panel.background = element_blank(),\n        panel.border = element_rect(colour = \"black\", fill = NA),\n        strip.background = element_rect(colour = \"NA\", fill = \"NA\"),\n        strip.placement = \"outside\",\n        strip.text = element_text(size = 10, angle = 0, vjust = 0.5, hjust = 0.5))\nplot(p1)\n\n\n\n\nFigure 1: Genes occupancy\n\n\n\n\n\n\n1.2.3 Gene alignments distributions\nNext, we retrieved the CDS sequences and we align them. To do so, first we extract all CDSs that are longer than 200 bp from the .fasta .gff files pairs for each organellar genome.\n\n#!/usr/bin/env bash\n\n# get CP genes list\ncut -f 9 00_cp_GenBank_RAW/*.gff \\\n  | sed \"s/Name=//g\" \\\n  | sed \"s/ .*//g\" \\\n  | grep \"accD\\|atp\\|ccsA\\|cemA\\|chlI\\|clpP\\|ftsH\\|infA\\|pafI\\|pbf1\\|pet\\|psa\\|psb30\\|psb\\|rbcL\\|rnl\\|rns\\|rpl\\|rpo\\|rps\\|rrn5\\|tufA\\|ycf\" \\\n  | sort -u \\\n  &gt; cp_gene_list.lst\n\n# extract CP fasta sequences\nwhile read GENE; do\n    for file in 00_cp_GenBank_RAW/*[0-9].fasta; do\n        grep $GENE $(basename $file .fasta).cds.gff &gt; tmp.gff;\n        bedtools getfasta -fi $file -bed tmp.gff | tr \":\" \" \";\n    done &gt; 01_cp_CDS/$GENE.fa;\n    rm tmp.gff;\ndone &lt; cp_gene_list.lst\n\n\n# get MT genes list\ncut -f 9 00_mt_GenBank_RAW/*.gff \\\n  | sed \"s/Name=//g\" \\\n  | sed \"s/ .*//g\" \\\n  | sed \"s/ATP/atp/g\" \\\n  | sed \"s/NAD/nad/\"  \\\n  | grep \"atp\\|cob\\|cox\\|nad\\|rpl\\|rps\" \\\n  | sort -u \\\n  &gt; mt_gene_list.lst\n\n# extract MT fasta sequences\nwhile read GENE; do\n    for file in 00_mt_GenBank_RAW/*[0-9].fasta; do\n        grep $GENE $(basename $file .fasta).cds.gff &gt; tmp.gff;\n        bedtools getfasta -fi $file -bed tmp.gff | tr \":\" \" \";\n    done &gt; 01_mt_CDS/$GENE.fa;\n    rm tmp.gff;\ndone &lt; mt_gene_list.lst\n\nWe will use faTrans to translate the nucleotidic sequences to the corresponding amino-acid sequences, MAFFT to align the amino-acid sequences for each gene, and finally pal2nal to translate the alignemts back at the nucleotidic level. We will do this both for the chloroplast and for the mitochondrial genes.\n\n#!/usr/bin/env bash\n\n# translate CP to amino-acid sequences\nfor file in 01_cp_CDS/*.fa; do\n  ~/bin/faTrans $file 02_cp_CDS_align/$(basename $file .fa).aa.fa;\ndone\n# translate MT to amino-acid sequences\nfor file in 01_mt_CDS/*.fa; do\n  ~/bin/faTrans $file 02_mt_CDS_align/$(basename $file .fa).aa.fa;\ndone\n\n# align amino-acid sequences\nls ./02_cp_CDS_align/ \\\n  | xargs -n 4 -P 8 -I {} sh -c \\\n  'mafft \\\n     --localpair \\\n     --maxiterate 1000 \\\n     --ep 0.123 \\\n     --thread 4 \\\n     ./02_cp_CDS_align/{} \\\n     &gt; ./02_cp_CDS_align/$(basename {} .aa.fa).aa.aln.fa'\n     \nls ./02_mt_CDS_align/ \\\n  | xargs -n 4 -P 8 -I {} sh -c \\\n  'mafft \\\n     --localpair \\\n     --maxiterate 1000 \\\n     --ep 0.123 \\\n     --thread 4 \\\n     ./02_mt_CDS_align/{} \\\n     &gt; ./02_mt_CDS_align/$(basename {} .aa.fa).aa.aln.fa'\n\n# translate back the alignments to codons\nfor file in ./02_cp_CDS_align/*.aa.aln.fa; do\n  perl ~/bin/pal2nal.v14/pal2nal.pl \\\n    $file \\\n    ./01_cp_CDS/$(basename $file .aa.aln.fa).fa \\\n    -output fasta \\\n    &gt; ./02_cp_CDS_align/$(basename $file .aa.aln.fa).fa;\ndone\n\nfor file in ./02_mt_CDS_align/*.aa.aln.fa; do\n  perl ~/bin/pal2nal.v14/pal2nal.pl \\\n    $file \\\n    ./01_mt_CDS/$(basename $file .aa.aln.fa).fa \\\n    -output fasta \\\n    &gt; ./02_mt_CDS_align/$(basename $file .aa.aln.fa).fa;\ndone\n\n# clean up\nrm ./02_cp_CDS_align/*.aa.fa \\\n  ./02_mt_CDS_align/*.aa.fa \\\n  ./02_cp_CDS_align/*.aa.aln.fa \\\n  ./02_mt_CDS_align/*.aa.aln.fa\n\nLet’s now fetch the length of the alignments in R.\n\n#!/usr/bin/env R\n\n# create gene distribution matrix\ngene_length_distributions = matrix(ncol = 2)\n\n# get cp length distributions\nfilenames = list.files(\n  \"./02_cp_CDS_align/\",\n  pattern = \"*.aln.fa\",\n  full.names = TRUE\n)\ncp_genes_length = lapply(filenames, n.readLines, n = 1, skip = 1)\nnames(cp_genes_length) = stringr::str_remove_all(filenames, \"./02_cp_CDS_align//\") %&gt;%\n  stringr::str_remove_all(\".aln.fa\")\nfor(i in 1:length(cp_genes_length)){\n  gene_length_distributions = rbind(gene_length_distributions, c(\"cp\", nchar(cp_genes_length[[i]][[1]])))\n  rownames(gene_length_distributions)[nrow(gene_length_distributions)] = names(cp_genes_length)[i]\n}\n\n# get mt length distributions\nfilenames = list.files(\n  \"./02_mt_CDS_align/\",\n  pattern = \"*.aln.fa\",\n  full.names = TRUE\n)\nmt_genes_length = lapply(filenames, n.readLines, n = 1, skip = 1)\nnames(mt_genes_length) = stringr::str_remove_all(filenames, \"./02_mt_CDS_align//\") %&gt;%\n  stringr::str_remove_all(\".aln.fa\")\nfor(i in 1:length(mt_genes_length)){\n  gene_length_distributions = rbind(gene_length_distributions, c(\"mt\", nchar(mt_genes_length[[i]][[1]])))\n  rownames(gene_length_distributions)[nrow(gene_length_distributions)] = names(mt_genes_length)[i]\n}\n\n# reformat table\ngene_length_distributions = as.data.frame(gene_length_distributions)\ngene_length_distributions = gene_length_distributions[-1, ]\nnames(gene_length_distributions) = c(\"Organell\", \"length (bp)\")\ngene_length_distributions$`length (bp)` = as.numeric(gene_length_distributions$`length (bp)`)\n\nAnd let’s plot the gene alignment distributions for the chloroplast and the mitochondrion.\n\n#!/usr/bin/env R\n\n# plot\np2 = ggplot(gene_length_distributions, aes(x = Organell, y = `length (bp)`, fill = Organell)) +\n  geom_point(aes(group = Organell, color = Organell), shape = \"|\", size = 5) +\n  geom_boxplot(aes(fill = Organell), alpha = 0.75, width = 0.125,\n               position = position_nudge(x = -0.1),\n               outlier.colour = NA) +\n  ggdist::stat_halfeye(aes(fill = Organell), alpha = 0.75, slab_color = \"grey45\", slab_size = 0.5, \n                       scale = 0.7, adjust = 1, justification = -0.05, .width = 0, point_colour = NA) +\n  scale_color_manual(values = c(\"#469d89\", \"steelblue\")) +\n  scale_fill_manual(values = c(\"#469d89\", \"steelblue\")) +\n  scale_y_continuous(labels = label_number(suffix = \" kbp\", scale = 1e-3)) +\n  coord_flip() +\n  labs(y = \"Gene Length\") +\n  theme(plot.title = element_text(size = 24, hjust = 0.5),\n        axis.ticks.y = element_blank(),\n        axis.title.x = element_text(size = 16),\n        axis.title.y = element_blank(),\n        axis.text.x = element_text(size = 14),\n        axis.text.y = element_text(size = 18),\n        legend.position = \"none\",\n        panel.background = element_blank(),\n        panel.grid.major = element_line(colour = \"grey85\"),\n        panel.grid.minor.x = element_line(colour = \"grey85\"),\n        panel.border = element_rect(colour = \"black\", fill = NA))\nplot(p2)\n\n\n\n\nFigure 2: Alignment length distributions",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ulva organellar genomes retrieval and preparation</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-dataset-overview.html#sec-lesson-learnt-cp-and-mt-dataset-overview",
    "href": "cp-and-mt-dataset-overview.html#sec-lesson-learnt-cp-and-mt-dataset-overview",
    "title": "1  Ulva organellar genomes retrieval and preparation",
    "section": "1.3 Lessons Learnt",
    "text": "1.3 Lessons Learnt\nSo far, we have learnt:\n\nTCGA is a public resource with a wide collection of samples from cancer biopsies from patients affected by 32 different cancer types.\nTCGA provides abundant molecular and clinical information for both biopsies and patients and it allows for patient stratification and therapeutic target discovery.\nCancers with kidneys as primary sites are the third most abundant samples available in TCGA (n = 1,030 samples), after breast (n = 1,246) and lung biopsies (n = 1,156), and provides an excellent yet challenging case-study.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ulva organellar genomes retrieval and preparation</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-dataset-overview.html#session-information",
    "href": "cp-and-mt-dataset-overview.html#session-information",
    "title": "1  Ulva organellar genomes retrieval and preparation",
    "section": "1.4 Session Information",
    "text": "1.4 Session Information\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-conda-linux-gnu (64-bit)\nRunning under: openSUSE Tumbleweed\n\nMatrix products: default\nBLAS/LAPACK: /home/andrea/miniforge3/envs/moai/lib/libmkl_rt.so.2;  LAPACK version 3.9.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=it_IT.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Europe/Brussels\ntzcode source: system (glibc)\n\nattached base packages:\n [1] parallel  stats4    grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] treeio_1.26.0         TreeDist_2.9.2        stringr_1.5.1        \n [4] scales_1.3.0          RColorBrewer_1.1-3    reshape_0.8.9        \n [7] phytools_2.4-4        maps_3.4.2.1          phylogram_2.1.0      \n[10] phangorn_2.12.1       gridExtra_2.3         ggtree_3.10.1        \n[13] ggplot2_3.5.1         ggdist_3.3.2          dplyr_1.1.4          \n[16] doSNOW_1.0.20         snow_0.4-4            iterators_1.0.14     \n[19] foreach_1.5.2         dendextend_1.19.0     DECIPHER_2.30.0      \n[22] RSQLite_2.3.9         Biostrings_2.70.3     GenomeInfoDb_1.38.8  \n[25] XVector_0.42.0        IRanges_2.36.0        S4Vectors_0.40.2     \n[28] BiocGenerics_0.48.1   corrplot_0.95         ComplexHeatmap_2.18.0\n[31] circlize_0.4.16       ape_5.8-1            \n\nloaded via a namespace (and not attached):\n  [1] jsonlite_1.8.9          shape_1.4.6.1           magrittr_2.0.3         \n  [4] farver_2.1.2            rmarkdown_2.29          GlobalOptions_0.1.2    \n  [7] fs_1.6.5                zlibbioc_1.48.2         vctrs_0.6.5            \n [10] memoise_2.0.1           RCurl_1.98-1.16         htmltools_0.5.8.1      \n [13] distributional_0.5.0    DEoptim_2.2-8           gridGraphics_0.5-1     \n [16] sass_0.4.9              bslib_0.8.0             htmlwidgets_1.6.4      \n [19] plyr_1.8.9              cachem_1.1.0            igraph_2.1.4           \n [22] mime_0.12               lifecycle_1.0.4         pkgconfig_2.0.3        \n [25] Matrix_1.6-5            R6_2.5.1                fastmap_1.2.0          \n [28] GenomeInfoDbData_1.2.11 rbibutils_2.3           shiny_1.10.0           \n [31] clue_0.3-66             digest_0.6.37           numDeriv_2016.8-1.1    \n [34] aplot_0.2.4             colorspace_2.1-1        patchwork_1.3.0        \n [37] crosstalk_1.2.1         labeling_0.4.3          clusterGeneration_1.3.8\n [40] compiler_4.3.2          bit64_4.6.0-1           withr_3.0.2            \n [43] doParallel_1.0.17       optimParallel_1.0-2     viridis_0.6.5          \n [46] DBI_1.2.3               R.utils_2.12.3          MASS_7.3-60.0.1        \n [49] rjson_0.2.23            scatterplot3d_0.3-44    tools_4.3.2            \n [52] httpuv_1.6.15           TreeTools_1.13.0        R.oo_1.27.0            \n [55] glue_1.8.0              quadprog_1.5-8          nlme_3.1-167           \n [58] R.cache_0.16.0          promises_1.3.2          reshape2_1.4.4         \n [61] cluster_2.1.8           PlotTools_0.3.1         generics_0.1.3         \n [64] gtable_0.3.6            R.methodsS3_1.8.2       tidyr_1.3.1            \n [67] pillar_1.10.1           yulab.utils_0.2.0       later_1.4.1            \n [70] lattice_0.22-6          bit_4.5.0.1             tidyselect_1.2.1       \n [73] knitr_1.49              xfun_0.50               expm_1.0-0             \n [76] matrixStats_1.5.0       DT_0.33                 stringi_1.8.4          \n [79] lazyeval_0.2.2          ggfun_0.1.8             yaml_2.3.10            \n [82] evaluate_1.0.3          codetools_0.2-20        tibble_3.2.1           \n [85] ggplotify_0.1.2         cli_3.6.3               xtable_1.8-4           \n [88] Rdpack_2.6.2            jquerylib_0.1.4         munsell_0.5.1          \n [91] Rcpp_1.0.14             coda_0.19-4.1           png_0.1-8              \n [94] blob_1.2.4              bitops_1.0-9            viridisLite_0.4.2      \n [97] tidytree_0.4.6          purrr_1.0.2             crayon_1.5.3           \n[100] combinat_0.0-8          GetoptLong_1.0.5        rlang_1.1.5            \n[103] fastmatch_1.1-6         mnormt_2.1.1            shinyjs_2.1.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ulva organellar genomes retrieval and preparation</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-phylogeny-reconstruction.html",
    "href": "cp-and-mt-phylogeny-reconstruction.html",
    "title": "2  Species tree reconstruction from organellar genomes",
    "section": "",
    "text": "2.1 On this page\nBiological insights and take-home messages are at the bottom of the page at Lesson Learnt: Section 2.3.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Species tree reconstruction from organellar genomes</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-phylogeny-reconstruction.html#on-this-page",
    "href": "cp-and-mt-phylogeny-reconstruction.html#on-this-page",
    "title": "2  Species tree reconstruction from organellar genomes",
    "section": "",
    "text": "Here we retrieve Ulva organellar genomes\nwe investigate the",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Species tree reconstruction from organellar genomes</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-phylogeny-reconstruction.html#reconstruction-of-ulva-species-tree",
    "href": "cp-and-mt-phylogeny-reconstruction.html#reconstruction-of-ulva-species-tree",
    "title": "2  Species tree reconstruction from organellar genomes",
    "section": "2.2 Reconstruction of Ulva species tree",
    "text": "2.2 Reconstruction of Ulva species tree\nWe will reconstruct the Ulva phylogenetic species tree using a Maximum Likelihood approach with IQ-TREE, and a coalescence-based one with ASTRAL. We will generate the species tree based on:\n\nchloroplast only genes\nmitochondrial only genes\nboth chloroplast and mitochondrial genes\n\nand we will evaluate the similarities and differences between the reconstructued phylogenies.\n\n2.2.1 Maximum Likelihodd species tree reconstruction\nFor the ML approach, the first step consist in concatenating all alignments into a single concatenated file. We will use catfasta2phyml to concatenate the nucleotidic sequences.\nWe want to apply different which also generates a nexus file that is required from IQ-TREE with the coordinates of each gene in the alignment. This allow us to partion the alignment to the gene level and apply different evolution models to different genes. Even if for each organelle all genes are inherited in linkage, the same is not true for the chloroplast and the mitochondrial genome. Moreover, this would allow to model different signals across genes that are under different evolutionary pressures.\nSINGLE GENE TREE\n\n#!/usr/bin/env bash\n\n# CP gene wise Maximum Likelihood phylogeny\nmkdir ./03_cp_singleGene_ML && cd ./03_cp_singleGene_ML\nls ../02_cp_CDS_align/*.fa \\\n  | xargs -P 8 -n 6 -I {} bash -c \\\n  ‘~/bin/iqtree-2.2.0-Linux/bin/iqtree2 -s {} \\\n    -st DNA \\\n    -pre $(basename {} .fa) \n    -nt 6 \\\n    -wbt -bb 1000 -alrt 1000 \\\n    -m MFP+MERGE’\n\n# MT gene wise Maximum Likelihood phylogeny\ncd ..\nmkdir ./03_mt_singleGene_ML && cd ./03_mt_singleGene_ML\nls ../02_mt_CDS_align/*.fa \\\n  | xargs -P 8 -n 6 -I {} bash -c \\\n  ‘~/bin/iqtree-2.2.0-Linux/bin/iqtree2 -s {} \\\n    -st DNA \\\n    -pre $(basename {} .fa) \n    -nt 6 \\\n    -wbt -bb 1000 -alrt 1000 \\\n    -m MFP+MERGE’\ncd ..\n\nNow we can create a nexus file with the best model predicted for each gene. This provides the best model for each partition (i.e.: gene) for the concatenated ML tree.\n\n#!/usr/bin/env bash\n\n# create nexus file with best models CP and MT \nfor ORGANEL in cp mt; do \n\n  k=1\n  START=0\n  \n  echo \"#nexus\" &gt; ./04_\"${ORGANEL}\"_concat_ML/head_noscaffold.nex\n  echo \"begin sets;\" &gt;&gt; ./04_\"${ORGANEL}\"_concat_ML/head_noscaffold.nex\n  echo -n \"charpartition mine = \" &gt;&gt; ./04_\"${ORGANEL}\"_concat_ML/tail_noscaffold.nex\n  \n  for file in ./02_\"${ORGANEL}\"_CDS_alin/*.fa; do\n    LEN=$(awk '/^&gt;/ {if (seqlen){print seqlen}; print ;seqlen=0;next; } { seqlen += length($0)}END{print seqlen}' $file | sed -n 2,2p)\n    echo \"charset part$k = $(($START+1))-$(($START+$LEN));\" &gt;&gt; ./04_\"${ORGANEL}\"_concat_ML/head_noscaffold.nex\n    START=$(($START+$LEN))\n    MODEL=$(grep \"Best-fit model\" ./02_\"${ORGANEL}\"_CDS_alin/$(basename $file .fa).log \\\n      | sed 's/Best-fit model: //g' \\\n      | sed 's/ chosen according to BIC//g')\n    echo -n \"$MODEL:part$k ,\" &gt;&gt; ./04_\"${ORGANEL}\"_concat_ML/tail_noscaffold.nex\n    k=$((k+1))\n  done\n  \n  echo \";\" &gt;&gt; ./04_\"${ORGANEL}\"_concat_ML/tail_noscaffold.nex\n  echo \"end;\" &gt;&gt; ./04_\"${ORGANEL}\"_concat_ML/tail_noscaffold.nex\n  \n  cat ./04_\"${ORGANEL}\"_concat_ML/head_noscaffold.nex \\\n    ./04_\"${ORGANEL}\"_concat_ML/tail_noscaffold.nex \\\n    &gt; ./04_\"${ORGANEL}\"_concat_ML/\"${ORGANEL}\"_allgenes_concat.nex\n    \n  rm ./04_\"${ORGANEL}\"_concat_ML/head_noscaffold.nex ./04_\"${ORGANEL}\"_concat_ML/tail_noscaffold.nex\n  sed -i 's/ ,;/;/g' ./04_\"${ORGANEL}\"_concat_ML/\"${ORGANEL}\"_allgenes_concat.nex\n\ndone\n\n# create a nexus file for CP+MT concatenated alignment\nk=1\nSTART=0\n\necho \"#nexus\" &gt; ./06_cp_mt_concat_ML/head_noscaffold.nex\necho \"begin sets;\" &gt;&gt; ./06_cp_mt_concat_ML/head_noscaffold.nex\necho -n \"charpartition mine = \" &gt;&gt; ./06_cp_mt_concat_ML/tail_noscaffold.nex\n\nfor file in ./02_cp_CDS_alin/*.fa ./02_mt_CDS_alin/*.fa; do\n  LEN=$(awk '/^&gt;/ {if (seqlen){print seqlen}; print ;seqlen=0;next; } { seqlen += length($0)}END{print seqlen}' $file | sed -n 2,2p)\n  echo \"charset part$k = $(($START+1))-$(($START+$LEN));\" &gt;&gt; ./06_cp_mt_concat_ML/head_noscaffold.nex\n  START=$(($START+$LEN))\n  MODEL=$(grep \"Best-fit model\" ./02_*_CDS_alin/$(basename $file .fa).log \\\n    | sed 's/Best-fit model: //g' \\\n    | sed 's/ chosen according to BIC//g')\n  echo -n \"$MODEL:part$k ,\" &gt;&gt; ./06_cp_mt_concat_ML/tail_noscaffold.nex\n  k=$((k+1))\ndone\n\necho \";\" &gt;&gt; ./06_cp_mt_concat_ML/tail_noscaffold.nex\necho \"end;\" &gt;&gt; ./06_cp_mt_concat_ML/tail_noscaffold.nex\n\ncat ./06_cp_mt_concat_ML/head_noscaffold.nex \\\n  ./06_cp_mt_concat_ML/tail_noscaffold.nex \\\n  &gt; ./06_cp_mt_concat_ML/cp_mt_allgenes_concat.nex\n  \nrm ./06_cp_mt_concat_ML/head_noscaffold.nex ./06_cp_mt_concat_ML/tail_noscaffold.nex\nsed -i 's/ ,;/;/g' ./06_cp_mt_concat_ML/cp_mt_allgenes_concat.nex\n\nWe will use catfasta2phyml to concatenate the nucleotidic sequences.\n\n#!/usr/bin/env bash\n\n# concatenate CP alignments\nperl ~/bin/catfasta2phyml.pl \\\n  --fasta \\\n  --concatenate 02_cp_CDS_align/*.fa \\\n  &gt; 08_concatenated_ML/clstr.all.concat.nt.align.fa\n  \n# concatenate MT alignments\nperl ~/bin/catfasta2phyml.pl \\\n  --fasta \\\n  --concatenate 02_mt_CDS_align/*.fa \\\n  &gt; 08_concatenated_ML/clstr.all.concat.nt.align.fa\n\n# concatenate CP+MT alignments\nperl ~/bin/catfasta2phyml.pl \\\n  --fasta \\\n  --concatenate 07_nt_aln_ready/*.fa \\\n  &gt; 06_cp_mt_concat_ML/clstr.all.concat.nt.align.fa\n\n# ML analysis on concatenated alignment\ncd ./04_cp_concat_ML/\n~/bin/iqtree-2.2.0-Linux/bin/iqtree2 \\\n  -s cp_allgenes_concat.fa \\\n  -st DNA \\\n  -pre cp_allgenes_concat \\\n  -p cp_allgenes_concat.nex \\\n  --sampling GENESITE \\\n  -nt 64 \\\n  -wbt -bb 1000 -alrt 1000 \n\ncd ../04_mt_concat_ML/\n~/bin/iqtree-2.2.0-Linux/bin/iqtree2 \\\n  -s mt_allgenes_concat.fa \\\n  -st DNA \\\n  -pre mt_allgenes_concat \\\n  -p mt_allgenes_concat.nex \\\n  --sampling GENESITE \\\n  -nt 64 \\\n  -wbt -bb 1000 -alrt 1000 \n\ncd ../06_cp_mt_concat_ML/\n~/bin/iqtree-2.2.0-Linux/bin/iqtree2 \\\n  -s cp_mt_allgenes_concat.fa \\\n  -st DNA \\\n  -pre cp_mt_allgenes_concat \\\n  -p cp_mt_allgenes_concat.nex \\\n  --sampling GENESITE \\\n  -nt 64 \\\n  -wbt -bb 1000 -alrt 1000 \n  \n\n\n\n2.2.2 Colescence-based species tree reconstruction\nFor the coalescence-based approach, first we need to compute the single-gene ML tree.\n\n\n\n\n\n2.2.3 Species trees comparison and reconciliation\nLet’s plot the Maximum Likelihood trees we have just reconstructed!\nFirst we import the trees in R.\n\n#!/usr/bin/env R\n\n# phylogenetic trees placeholder\nphylogenetic_trees = list(\n  \"cp_ML\" = list(\"type\" = \"ML\", \"tree\" = NA, \"root\" = NA, \"dendro\" = NA),\n  \"cp_ASTRAL\" = list(\"type\" = \"coalescent\", \"tree\" = NA, \"root\" = NA, \"dendro\" = NA),\n  \"mt_ML\" = list(\"type\" = \"ML\", \"tree\" = NA, \"root\" = NA, \"dendro\" = NA),\n  \"mt_ASTRAL\" = list(\"type\" = \"coalescent\", \"tree\" = NA, \"root\" = NA, \"dendro\" = NA),\n  \"cp_mt_ML\" = list(\"type\" = \"ML\", \"tree\" = NA, \"root\" = NA, \"dendro\" = NA),\n  \"cp_mt_ASTRAL\" = list(\"type\" = \"coalescent\", \"tree\" = NA, \"root\" = NA, \"dendro\" = NA)\n)\n\n# read ML concatenated trees\nphylogenetic_trees[[\"cp_ML\"]][[\"tree\"]] = ape::read.tree(file = \"./data/cp_allgenes_concat.contree\")\nphylogenetic_trees[[\"mt_ML\"]][[\"tree\"]] = ape::read.tree(file = \"./data/mt_allgenes_concat.contree\")\nphylogenetic_trees[[\"cp_mt_ML\"]][[\"tree\"]] = ape::read.tree(file = \"./data/cp_mt_allgenes_concat.contree\")\n\n# read coalescence-based trees\nphylogenetic_trees[[\"cp_ASTRAL\"]][[\"tree\"]] = ape::read.tree(file = \"./data/cp_genetrees.coalescence.tre\")\nphylogenetic_trees[[\"mt_ASTRAL\"]][[\"tree\"]] = ape::read.tree(file = \"./data/mt_genetrees.coalescence.tre\")\nphylogenetic_trees[[\"cp_mt_ASTRAL\"]][[\"tree\"]] = ape::read.tree(file = \"./data/cp_mt_genetrees.coalescence.tre\")\n\n# reroot trees\nfor(i in 1:length(phylogenetic_trees)){\n  \n  # get root position\n  phylogenetic_trees[[i]][[\"root\"]] = tidytree::MRCA(phylogenetic_trees[[i]][[\"tree\"]], \"Pakin\", \"Oviri\")\n  \n  # reroot set branch length NaN to 0 in coalescent trees and root length to 0.01 in ML trees\n  if(phylogenetic_trees[[i]][[\"type\"]] == \"coalescent\"){\n    phylogenetic_trees[[i]][[\"tree\"]] = treeio::root(phylogenetic_trees[[i]][[\"tree\"]], node = phylogenetic_trees[[i]][[\"root\"]], resolve.root = TRUE)\n    phylogenetic_trees[[i]][[\"tree\"]]$edge.length[is.na(phylogenetic_trees[[i]][[\"tree\"]]$edge.length)] = 0\n    phylogenetic_trees[[i]][[\"tree\"]]$node.label = ifelse(phylogenetic_trees[[i]][[\"tree\"]]$node.label == \"Root\", \"1\", phylogenetic_trees[[i]][[\"tree\"]]$node.label)\n    phylogenetic_trees[[i]][[\"tree\"]]$node.label = ifelse(phylogenetic_trees[[i]][[\"tree\"]]$node.label == \"\", \"1\", phylogenetic_trees[[i]][[\"tree\"]]$node.label)\n  } else {\n    phylogenetic_trees[[i]][[\"tree\"]] = treeio::root(phylogenetic_trees[[i]][[\"tree\"]], node = phylogenetic_trees[[i]][[\"root\"]] + 1, resolve.root = TRUE)\n    phylogenetic_trees[[i]][[\"tree\"]]$edge.length[which(phylogenetic_trees[[i]][[\"tree\"]]$edge.length == 0)] = 0.1\n    phylogenetic_trees[[i]][[\"tree\"]]$node.label = ifelse(phylogenetic_trees[[i]][[\"tree\"]]$node.label == \"Root\", \"100\", phylogenetic_trees[[i]][[\"tree\"]]$node.label)\n    phylogenetic_trees[[i]][[\"tree\"]]$node.label = ifelse(phylogenetic_trees[[i]][[\"tree\"]]$node.label == \"\", \"100\", phylogenetic_trees[[i]][[\"tree\"]]$node.label)\n  }\n  \n  # sort trees in descending order\n  phylogenetic_trees[[i]][[\"tree\"]] = ape::ladderize(phylogenetic_trees[[i]][[\"tree\"]], right = TRUE)\n  \n  # set node label to numeric (BS and coalescence support)\n  phylogenetic_trees[[i]][[\"tree\"]]$node.label = as.numeric(phylogenetic_trees[[i]][[\"tree\"]]$node.label)\n  \n}\n\nLets now plot a tanglegram: we will have the ML tree and the ASTRAL tree facing each other, and lines connecting the corresponding position of the same alga isolate. This will allow us to compare the two three structure, as well as how much concordant are the phylogenetic reconstructions.\nWe will do this for the cp + mt, cp only and mt only gene sets.\n\nChloroplast + Mitochondrial ML treeChloroplast ML treeMitochondrial ML tree\n\n\n\n#!/usr/bin/env R\n\nML_tree = phylogenetic_trees[[\"cp_mt_ML\"]][[\"tree\"]]\nML_tree = groupClade(ML_tree, 53)\n\n# prep ML tree\np_ML = ggtree(ML_tree, aes(linetype = group)) +\n  scale_linetype_discrete(guide = \"none\")\n\np_ML$data[p_ML$data$node %in% c(1, 2), \"x\"] = mean(p_ML$data$x)\np_ML$data[p_ML$data$node %in% c(53), \"x\"] = mean(p_ML$data$x)/2\n\np_ML = ggtree::rotate(p_ML, 52) \n\n# prep ASTRAL tree\nASTRAL_tree = phylogenetic_trees[[\"cp_mt_ASTRAL\"]][[\"tree\"]]\nASTRAL_tree = groupClade(ASTRAL_tree, 101)\n\np_ASTRAL = ggtree(ASTRAL_tree, aes(linetype = group)) +\n  scale_linetype_discrete(guide = \"none\")\n\np_ASTRAL$data[p_ASTRAL$data$node %in% c(13, 12), \"x\"] = max(p_ASTRAL$data$x)\np_ASTRAL$data[p_ASTRAL$data$node %in% c(101), \"x\"] = max(p_ASTRAL$data$x)/2\n\np_ASTRAL = ggtree::rotate(p_ASTRAL, 52) +\n  geom_tiplab(color = \"black\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0.7) +\n  geom_nodepoint(aes(fill = cut(as.numeric(label), c(0, 0.70, 0.90, 1.00))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"white\", \"grey\", \"black\")) +\n  theme(legend.position = \"none\")\n\n# get tree data\nd_ML = p_ML$data \nd_ASTRAL = p_ASTRAL$data\n\n# rescale ASTRAL tree to ML tree space\nscale_ratio_bl = max(d_ML$branch.length) / max(d_ASTRAL$branch.length)\nscale_ratio_x = max(d_ML$x) / max(d_ASTRAL$x)\nscale_ratio_b = max(d_ML$branch) / max(d_ASTRAL$branch) \nd_ASTRAL$branch.length = d_ASTRAL$branch.length * scale_ratio_bl\nd_ASTRAL$x = d_ASTRAL$x * scale_ratio_x\nd_ASTRAL$branch = d_ASTRAL$branch * scale_ratio_b\n\n# reverse x-axis and set offset to make ASTRAL tree on the right-hand side of ML tree\nd_ASTRAL$x = max(d_ASTRAL$x) - d_ASTRAL$x + max(d_ML$x) + 0.1\n\n\n# combine trees\np_combined = p_ML +\n  geom_nodepoint(aes(fill = cut(as.numeric(label),\n                                c(0, 70, 90, 100))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"black\", \"grey\", \"white\"),\n                    guide = \"legend\",\n                    name = \"Bootstrap\",\n                    breaks = c(\"(90,100]\", \"(70,90]\", \"(0,70]\"),\n                    labels = expression(BP&gt;=90,70 &lt;= BP * \" &lt; 90\", BP &lt; 70)) +\n  labs(title = \"cp + mt, 99 genes\") +\n  theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"bottom\") +\n  geom_tree(data = d_ASTRAL) +\n  #geom_tiplab(data = d_ASTRAL, color = \"black\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0.7) +\n  ggnewscale::new_scale_fill() +\n  geom_nodepoint(data = d_ASTRAL, aes(fill = cut(as.numeric(label), c(0, 0.70, 0.90, 1.00))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"white\", \"grey\", \"black\"), guide = \"none\")\n\n# combine tip data\nd_ML$x = max(d_ML$x) + 0.05\nd_ASTRAL$x = d_ASTRAL$x - 0.0125\nd_labels = dplyr::bind_rows(d_ML, d_ASTRAL) %&gt;%\n  dplyr::filter(isTip == TRUE)\nd_labels$color_group = ifelse(\n  d_labels$label %in% c(\"Ufene\", \"Usp4\"), \"red\",\n  ifelse(d_labels$label %in% c(\n    \"Uaust1\", \"Uaust2\", \"Uaust4\", \"Ufaust5\", \"Ufaust6\",\n    \"Ucomp1\", \"Ucomp2\", \"Ucomp3\", \"Ucomp4\", \"Ucomp5\", \"Ucomp6\", \"Ucomp7\", \"Ucomp8\", \"Ucomp9\", \"Ucomp10\",\n    \"Ulact2\", \"Ulact3\",\n    \"Umeri1\", \"Umeri3\", \"Umeri4\", \"Umeri5\"), \"grey\", \"steelblue\")\n)\n\np_combined +\n  geom_tiplab(color = \"antiquewhite3\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0.7) +\n  geom_tiplab(color = \"black\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0) +\n  geom_line(data = d_labels, aes(x, y, group = label, color = color_group)) +\n  scale_color_manual(values = c(\"grey\", \"red\", \"steelblue\"), guide = FALSE)\n\n\n\n\nFigure 1: cp + mt species tree reconstruction\n\n\n\n\n\n\n\n#!/usr/bin/env R\n\nML_tree = phylogenetic_trees[[\"cp_ML\"]][[\"tree\"]]\nML_tree = groupClade(ML_tree, 37)\n\n# prep ML tree\np_ML = ggtree(ML_tree, aes(linetype = group)) +\n  scale_linetype_discrete(guide = \"none\")\n\np_ML$data[p_ML$data$node %in% c(1, 2), \"x\"] = mean(p_ML$data$x)\np_ML$data[p_ML$data$node %in% c(38), \"x\"] = mean(p_ML$data$x)/2\n\np_ML = ggtree::rotate(p_ML, 37) \n\n# prep ASTRAL tree\nASTRAL_tree = phylogenetic_trees[[\"cp_ASTRAL\"]][[\"tree\"]]\nASTRAL_tree = groupClade(ASTRAL_tree, 37)\n\np_ASTRAL = ggtree(ASTRAL_tree, aes(linetype = group)) +\n  scale_linetype_discrete(guide = \"none\")\n\np_ASTRAL$data[p_ASTRAL$data$node %in% c(20, 21), \"x\"] = max(p_ASTRAL$data$x)\np_ASTRAL$data[p_ASTRAL$data$node %in% c(71), \"x\"] = max(p_ASTRAL$data$x)/2\n\np_ASTRAL = ggtree::rotate(p_ASTRAL, 37) +\n  geom_tiplab(color = \"black\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0.7) +\n  geom_nodepoint(aes(fill = cut(as.numeric(label), c(0, 0.70, 0.90, 1.00))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"white\", \"grey\", \"black\")) +\n  theme(legend.position = \"none\")\n\n# get tree data\nd_ML = p_ML$data \nd_ASTRAL = p_ASTRAL$data\n\n# rescale ASTRAL tree to ML tree space\nscale_ratio_bl = max(d_ML$branch.length) / max(d_ASTRAL$branch.length)\nscale_ratio_x = max(d_ML$x) / max(d_ASTRAL$x)\nscale_ratio_b = max(d_ML$branch) / max(d_ASTRAL$branch) \nd_ASTRAL$branch.length = d_ASTRAL$branch.length * scale_ratio_bl\nd_ASTRAL$x = d_ASTRAL$x * scale_ratio_x\nd_ASTRAL$branch = d_ASTRAL$branch * scale_ratio_b\n\n# reverse x-axis and set offset to make ASTRAL tree on the right-hand side of ML tree\nd_ASTRAL$x = max(d_ASTRAL$x) - d_ASTRAL$x + max(d_ML$x) + 0.1\n\n\n# combine trees\np_combined = p_ML +\n  geom_nodepoint(aes(fill = cut(as.numeric(label),\n                                c(0, 70, 90, 100))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"black\", \"grey\", \"white\"),\n                    guide = \"legend\",\n                    name = \"Bootstrap\",\n                    breaks = c(\"(90,100]\", \"(70,90]\", \"(0,70]\"),\n                    labels = expression(BP&gt;=90,70 &lt;= BP * \" &lt; 90\", BP &lt; 70)) +\n  labs(title = \"cp, 70 genes\") +\n  theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"bottom\") +\n  geom_tree(data = d_ASTRAL) +\n  ggnewscale::new_scale_fill() +\n  geom_nodepoint(data = d_ASTRAL, aes(fill = cut(as.numeric(label), c(0, 0.70, 0.90, 1.00))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"white\", \"grey\", \"black\"), guide = \"none\")\n\n# combine tip data\nd_ML$x = max(d_ML$x) + 0.05\nd_ASTRAL$x = d_ASTRAL$x - 0.0125\nd_labels = dplyr::bind_rows(d_ML, d_ASTRAL) %&gt;%\n  dplyr::filter(isTip == TRUE)\nd_labels$color_group = ifelse(\n  d_labels$label %in% c(\n    \"Ucomp5\", \"Ucomp9\", \"Ucomp10\", \"Ucomp3\", \"Ucomp1\", \"Ucomp2\", \"Ucomp6\", \"Ucomp4\",\n    \"Ulinz\", \"Uprol3\", \"Uprol2\", \"Utort\", \"Uflex1\", \"Ucali\",\n    \"Umeri7\", \"Umeri6\", \"Usp2\", \"Uprol1\",\n    \"Ulaci1\", \"Uaust3\", \"Urigi1\", \"Ulaci2\"\n  ), \"grey\", \"steelblue\"\n)\n\np_combined +\n  geom_tiplab(color = \"antiquewhite3\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0.7) +\n  geom_tiplab(color = \"black\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0) +\n  geom_line(data = d_labels, aes(x, y, group = label, color = color_group)) +\n  scale_color_manual(values = c(\"grey\", \"steelblue\"), guide = FALSE)\n\n\n\n\nFigure 2: cp species tree reconstruction\n\n\n\n\n\n\n\n#!/usr/bin/env R\n\nML_tree = phylogenetic_trees[[\"mt_ML\"]][[\"tree\"]]\nML_tree = groupClade(ML_tree, 40)\n\n# prep ML tree\np_ML = ggtree(ML_tree, aes(linetype = group)) +\n  scale_linetype_discrete(guide = \"none\")\n\np_ML$data[p_ML$data$node %in% c(1, 2), \"x\"] = mean(p_ML$data$x)\np_ML$data[p_ML$data$node %in% c(41), \"x\"] = mean(p_ML$data$x)/2\n\np_ML = ggtree::rotate(p_ML, 40) \n\n# prep ASTRAL tree\nASTRAL_tree = phylogenetic_trees[[\"mt_ASTRAL\"]][[\"tree\"]]\nASTRAL_tree = groupClade(ASTRAL_tree, 40)\n\np_ASTRAL = ggtree(ASTRAL_tree, aes(linetype = group)) +\n  scale_linetype_discrete(guide = \"none\")\n\np_ASTRAL$data[p_ASTRAL$data$node %in% c(25, 24), \"x\"] = max(p_ASTRAL$data$x)\np_ASTRAL$data[p_ASTRAL$data$node %in% c(77), \"x\"] = max(p_ASTRAL$data$x)/2\n\np_ASTRAL = ggtree::rotate(p_ASTRAL, 40) +\n  geom_tiplab(color = \"black\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0.7) +\n  geom_nodepoint(aes(fill = cut(as.numeric(label), c(0, 0.70, 0.90, 1.00))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"white\", \"grey\", \"black\")) +\n  theme(legend.position = \"none\")\n\n# get tree data\nd_ML = p_ML$data \nd_ASTRAL = p_ASTRAL$data\n\n# rescale ASTRAL tree to ML tree space\nscale_ratio_bl = max(d_ML$branch.length) / max(d_ASTRAL$branch.length)\nscale_ratio_x = max(d_ML$x) / max(d_ASTRAL$x)\nscale_ratio_b = max(d_ML$branch) / max(d_ASTRAL$branch) \nd_ASTRAL$branch.length = d_ASTRAL$branch.length * scale_ratio_bl\nd_ASTRAL$x = d_ASTRAL$x * scale_ratio_x\nd_ASTRAL$branch = d_ASTRAL$branch * scale_ratio_b\n\n# reverse x-axis and set offset to make ASTRAL tree on the right-hand side of ML tree\nd_ASTRAL$x = max(d_ASTRAL$x) - d_ASTRAL$x + max(d_ML$x) + 0.1\n\n\n# combine trees\np_combined = p_ML +\n  geom_nodepoint(aes(fill = cut(as.numeric(label),\n                                c(0, 70, 90, 100))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"black\", \"grey\", \"white\"),\n                    guide = \"legend\",\n                    name = \"Bootstrap\",\n                    breaks = c(\"(90,100]\", \"(70,90]\", \"(0,70]\"),\n                    labels = expression(BP&gt;=90,70 &lt;= BP * \" &lt; 90\", BP &lt; 70)) +\n  labs(title = \"mt, 29 genes\") +\n  theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"bottom\") +\n  geom_tree(data = d_ASTRAL) +\n  ggnewscale::new_scale_fill() +\n  geom_nodepoint(data = d_ASTRAL, aes(fill = cut(as.numeric(label), c(0, 0.70, 0.90, 1.00))), shape = 21, size = 3) +\n  scale_fill_manual(values = c(\"white\", \"grey\", \"black\"), guide = \"none\")\n\n# combine tip data\nd_ML$x = max(d_ML$x) + 0.05\nd_ASTRAL$x = d_ASTRAL$x - 0.0125\nd_labels = dplyr::bind_rows(d_ML, d_ASTRAL) %&gt;%\n  dplyr::filter(isTip == TRUE)\nd_labels$color_group = ifelse(\n  d_labels$label %in% c(\"Usp3\", \"Utort\", \"Umeri6\", \"Usp4\", \"Urigi3\", \"Ufene\"), \"red\", \"grey\"\n)\n\np_combined +\n  geom_tiplab(color = \"antiquewhite3\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0.7) +\n  geom_tiplab(color = \"black\", size = 2.75, align = TRUE, linetype = \"dotted\", linesize = 0) +\n  geom_line(data = d_labels, aes(x, y, group = label, color = color_group)) +\n  scale_color_manual(values = c(\"grey\", \"red\", \"steelblue\"), guide = FALSE)\n\n\n\n\nFigure 3: mt species tree reconstruction\n\n\n\n\n\n\n\ncp + mt good except for “Ufene” and “Usp4” position. cp cannot solve clade orders, while “species” refinition remane the same mt is a trainwreck\n\n\n2.2.4 distances between reconstructed species trees\nLet’s check how similar / different are the reconstructed trees. We will use four metrics:\n\n“common_nodes_corr”\n“RF”\n“KF”\n“MAST_%”\n\nFirst we calculate the distances:\n\n#!/usr/bin/env R\n\n# get list of dendrograms to compare\ndendro_list = dendextend::dendlist(\n  \"cp_ML\" = phylogenetic_trees[[\"cp_ML\"]][[\"tree\"]] %&gt;%\n    ape::chronos() %&gt;%\n    stats::as.dendrogram(),\n  \"cp_ASTRAL\" = phylogenetic_trees[[\"cp_ASTRAL\"]][[\"tree\"]] %&gt;%\n    ape::chronos() %&gt;%\n    stats::as.dendrogram(),\n  \"mt_ML\" = phylogenetic_trees[[\"mt_ML\"]][[\"tree\"]] %&gt;%\n    ape::chronos() %&gt;%\n    stats::as.dendrogram(),\n  \"mt_ASTRAL\" = phylogenetic_trees[[\"mt_ASTRAL\"]][[\"tree\"]] %&gt;%\n    ape::chronos() %&gt;%\n    stats::as.dendrogram(),\n  \"cp_mt_ML\" = phylogenetic_trees[[\"cp_mt_ML\"]][[\"tree\"]] %&gt;%\n    ape::chronos() %&gt;%\n    stats::as.dendrogram(),\n  \"cp_mt_ASTRAL\" = phylogenetic_trees[[\"cp_mt_ASTRAL\"]][[\"tree\"]] %&gt;%\n    ape::chronos() %&gt;%\n    stats::as.dendrogram()\n)\n\n\nSetting initial dates...\nFitting in progress... get a first set of estimates\n         (Penalised) log-lik = -5.506629 \nOptimising rates... dates... -5.506629 \nOptimising rates... dates... -5.391076 \n\nlog-Lik = -5.745963 \nPHIIC = 227.39 \n\nSetting initial dates...\nFitting in progress... get a first set of estimates\n         (Penalised) log-lik = -41.0089 \nOptimising rates... dates... -41.0089 \nOptimising rates... dates... -41.0089 \n\nlog-Lik = -40.14699 \nPHIIC = 295.47 \n\nSetting initial dates...\nFitting in progress... get a first set of estimates\n         (Penalised) log-lik = -3.093321 \nOptimising rates... dates... -3.093321 \nOptimising rates... dates... -2.767643 \n\nlog-Lik = -11.12947 \nPHIIC = 454.49 \n\nSetting initial dates...\nFitting in progress... get a first set of estimates\n         (Penalised) log-lik = -66.71373 \nOptimising rates... dates... -66.71373 \nOptimising rates... dates... -66.71269 \n\nlog-Lik = -65.14702 \nPHIIC = 360.65 \n\nSetting initial dates...\nFitting in progress... get a first set of estimates\n         (Penalised) log-lik = -6.654174 \nOptimising rates... dates... -6.654174 \nOptimising rates... dates... -6.420461 \n\nlog-Lik = -7.69423 \nPHIIC = 339.7 \n\nSetting initial dates...\nFitting in progress... get a first set of estimates\n         (Penalised) log-lik = -15019.6 \nOptimising rates... dates... -15019.6 \n\n\n\nlog-Lik = -1e+100 \nPHIIC = 2e+100 \n\n# create empty lists for distances and correlations\nempty_matrix = matrix(nrow = 6, ncol = 6)\ncolnames(empty_matrix) = c(\"cp_ML\", \"cp_ASTRAL\", \"mt_ML\", \"mt_ASTRAL\", \"cp_mt_ML\", \"cp_mt_ASTRAL\")\nrownames(empty_matrix) = c(\"cp_ML\", \"cp_ASTRAL\", \"mt_ML\", \"mt_ASTRAL\", \"cp_mt_ML\", \"cp_mt_ASTRAL\")\ndist_DB_pairwise = list(\n  \"common_nodes_corr\" = empty_matrix,\n  \"RF\" = empty_matrix,\n  \"KF\" = empty_matrix,\n  \"MAST_%\" = empty_matrix\n)\ndist_DB_min_set_species = list(\n  \"common_nodes_corr\" = empty_matrix,\n  \"RF\" = empty_matrix,\n  \"KF\" = empty_matrix,\n  \"MAST_%\" = empty_matrix\n)\n\n# common nodes correlation\ncommon_nodes_corr = dendextend::cor.dendlist(dendro_list, method = \"common_nodes\")\ndist_DB_pairwise[[\"common_nodes_corr\"]] = common_nodes_corr\ndist_DB_min_set_species[[\"common_nodes_corr\"]] = common_nodes_corr\n\n# get pairwise distances\nfor(i in 1:length(phylogenetic_trees)){\n  for(k in 1:length(phylogenetic_trees)){\n    \n    # get tree\n    tree1_tmp = phylogenetic_trees[[i]][[\"tree\"]]\n    tree2_tmp = phylogenetic_trees[[k]][[\"tree\"]]\n    \n    # list of common species\n    species_list = tree1_tmp$tip.label[which(tree1_tmp$tip.label %in% tree2_tmp$tip.label)]\n\n    # get overlapping species\n    tree1 = ape::keep.tip(tree1_tmp, species_list)\n    tree2 = ape::keep.tip(tree2_tmp, species_list)\n    \n    # get distances\n    distances = phangorn::treedist(tree1, tree2)\n    dist_DB_pairwise[[\"RF\"]][i, k] = distances[[1]]\n    dist_DB_pairwise[[\"KF\"]][i, k] = distances[[2]]\n    #dist_DB_pairwise[[\"path_diff\"]][i, k] = distances[[3]]\n    dist_DB_pairwise[[\"MAST_%\"]][i, k] = length(phangorn::mast(tree1, tree2, tree = FALSE)) / length(species_list)\n    \n    # clean\n    rm(tree1_tmp, tree2_tmp, tree1, tree2, species_list, distances)\n  }\n}\n\n# make list of minimum set of species\nmin_species_list = phylogenetic_trees[[\"cp_mt_ML\"]][[\"tree\"]]$tip.label\nfor(i in 1:length(phylogenetic_trees)){\n  min_species_list = min_species_list[which(min_species_list %in% phylogenetic_trees[[i]][[\"tree\"]]$tip.label)]\n}\n\n# get distances based on minimum set of species\nfor(i in 1:length(phylogenetic_trees)){\n  for(k in 1:length(phylogenetic_trees)){\n\n    # get overlapping species\n    tree1 = ape::keep.tip(phylogenetic_trees[[i]][[\"tree\"]], min_species_list)\n    tree2 = ape::keep.tip(phylogenetic_trees[[k]][[\"tree\"]], min_species_list)\n    \n    # get distances\n    distances = phangorn::treedist(tree1, tree2)\n    dist_DB_min_set_species[[\"RF\"]][i, k] = distances[[1]]\n    dist_DB_min_set_species[[\"KF\"]][i, k] = distances[[2]]\n    #dist_DB_min_set_species[[\"path_diff\"]][i, k] = distances[[3]]\n    dist_DB_min_set_species[[\"MAST_%\"]][i, k] = length(phangorn::mast(tree1, tree2, tree = FALSE)) / length(min_species_list)\n    \n    # clean\n    rm(tree1, tree2, distances)\n  }\n}\n\nThen we plot them based on the pairwise label sets between trees\n\n#!/usr/bin/env R\n\n# prepare plot layout\nlayout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = TRUE))\n\nfor(i in 1:length(dist_DB_pairwise)){\n  # parameters for correlation VS distances\n  correlation = FALSE\n  color_scale = list(\n    rev(COL2(\"RdBu\")),\n    COL1(\"Blues\"),\n    COL1(\"Blues\"),\n    COL1(\"YlOrRd\")\n  )\n  tile_shape = \"color\"\n  if(i == 1){\n    correlation = TRUE\n    tile_shape = \"pie\"\n  }\n  # plot\n  corrplot::corrplot(\n    dist_DB_pairwise[[i]],\n    title = names(dist_DB_pairwise)[[i]],\n    tile_shape, \n    \"upper\",\n    order = \"original\",\n    is.corr = correlation,\n    col = color_scale[[i]],\n    tl.srt = 45,\n    tl.col = \"grey15\",\n    mar = c(0, 0, 2, 0),\n    cl.pos = \"r\",\n    cl.align.text = \"l\"\n  )\n}\n\n\n\n\nFigure 4: species trees distance based on pairwise label sets between trees\n\n\n\n# reset layout\npar(mfrow = c(1, 1))\n\nWe can also see what are the distances if we restrict ourselves only to the isolates for which we have both the cp and the mt genomes (i.e.: full occupancy matrix)\n\n#!/usr/bin/env R\n\n# prepare plot layout\nlayout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = TRUE))\n\nfor(i in 1:length(dist_DB_min_set_species)){\n  # parameters for correlation VS distances\n  correlation = FALSE\n  color_scale = list(\n    rev(COL2(\"RdBu\")),\n    COL1(\"Blues\"),\n    COL1(\"Blues\"),\n    COL1(\"YlOrRd\")\n  )\n  tile_shape = \"color\"\n  if(i == 1){\n    correlation = TRUE\n    tile_shape = \"pie\"\n  }\n  # plot\n  corrplot::corrplot(\n    dist_DB_min_set_species[[i]],\n    title = names(dist_DB_min_set_species)[[i]],\n    tile_shape, \n    \"upper\",\n    order = \"original\", \n    is.corr = correlation,\n    col = color_scale[[i]],\n    tl.srt = 45,\n    tl.col = \"grey15\",\n    mar = c(0, 0, 2, 0),\n    cl.pos = \"r\",\n    cl.align.text = \"l\")\n}\n\n\n\n\nFigure 5: species trees distance based on overlapping cp+mt isolates\n\n\n\n# reset layout\npar(mfrow = c(1, 1))\n\n\n\n2.2.5 Prognosis Outcome\nOf the 887 petients with kidney tumor, 659 were alive at the time of the last check up, while 228 died. It appears that KIRC patients (48.7% dead) have worse prognosis than KIRP patients (17.9% dead), as observed in the previous comparisons. However, before drawing a formal conclusion, we should validate this observation at least in another independent cohort.\nTrees estimated by the ML and coalescent methods were well-supported and congruent, although slightly different topologies were recovered for different methods applied for different datasets (cp, mt and cp+mt) (Fig.1, Fig. S3). For the cp+mt tree, the topology of ML and coalescent trees are mostly congruent. The difference in the topology happens mostly within large species clades, e.g., clade contains U. australis or U. compressa genomes. The notorious difference is the position of U.fene vs. Ulva sp4. The results from the correlation between the common nodes and MAST% are highly concordant. They indicate that the topology of phylogenetic trees constructed by the two methods (ML and coalescence) and different datasets (cp, mt and cp+mt) is highly similar, except for the topology of the mt phylogenetic tree constructed by the ML method (The correlation between the common nodes) and the coalescent method (MAST%). Results from RF and KF matrices are more varied, but both also show the topology of species tree constructed using mt genomes ML is less similar compared to other species trees.\nFigure 1. (A). Consensus Ulva species tree based on the (49) concatenated chloroplast and mitochondrial genomes. The colors of circle at each node show the confident level of supporting values (bootstrap value for ML tree and posterior value for coalescence tree). Black circles indicate nodes with at least 95% support while grey circles indicate nodes with support values in the range of 75-95% and white circles indicate nodes with support values less than 75%. The blue lines show the identical topology between ML and coalescence tree while grey lines indicate difference in topology within species and red lines indicate difference in topology between species. (B). Four metrics, namely the correlation between the common nodes (common_nodes_corr), Robinson-Foulds (RF), Kuhner-Felsenstein (KF), and Maximum Agreement Subtree (MAST) used to assess the concordance of the Ulva species tree reconstructed from supermatrix and coalescence-based analyses obtained from the analyses of chloroplast genes, mitochondrial genes and chloroplast and mitochondrial genes. Higher values in correlation between the common_nodes_corr and MAST indicate the higher similarity between topology while lower values in correlation between the RF and KF indicate the higher similarity between topology.\nAmong the 70 cp genes chosen, the four indices RF, KF, MAST and the correlation between the common nodes metrics pointed out 24 unique cp genes that provide the most similar topology compared to the species tree constructed using 70 genes, namely accD, atpF, chlI, petB, psaA, psaB, psbB, psbD, rpl12, rpl19, rpl2, rpl32, rpoA, rpoB, rpoC1, rpoC2, rps12, rps2, rps4, rps8, rps9, tufA, ycf1, and ycf20 (Table 1). Among them, several genes such as psaA, psaB, and psbB are consistently identified by different matrices. Similarly, the same approach applied to the Ulva species trees reconstructed using mt suggested 19 unique mt genes, namely atp1, atp6, cob, cox1, cox2, cox3, nad2, nad4, nad5, nad7, rpl14, rpl16, rps10, rps11, rps14, rps19, rps2, rps3, and rps4, of which several genes such as atp6, cox1, cox2, rps3, and rps10 are suggested by different indices. Since the Ulva specimens used in this study do not always have both cp and mt genomes, the Ulva species trees reconstructed using cp and mt supermatrix have different set of tips, depending on the availability of the genomes. Prior analyses suggested that MAST% and common correlation nodes metrics are the best performers to assess phylogenetic tree distances when the tree do not have the same set of tips, we then selected (arbitrarily) 10 genes for the combinatorial approach, petB, psaA, psaB, psbB, psbD, rps2, atp6, cox1, cox2, and mt_rps3, based on the top 10 single gene ML trees with topology closest to cp_mt_ML. The first six genes are cp genes while the other four genes are mt genes.\nFrom the combination of 2 to 10 selected genes, 1,013 species trees were generated (45 species trees for 2 genes, 120 species trees for 3 genes, 210 species trees for 4 genes, 252 species trees for 5 genes,210 species trees for 6 genes, 120 species trees for 7 genes, 45 species trees for 8 genes, 10 species trees for 9 genes and 1 species trees for 10 genes). After filtering for combinations containing both a cp and an mt marker, a total of 945 trees remained, comprising of 24 species trees for 2 genes, 96 species trees for 3 genes, 194 species trees for 4 genes, 246 species trees for 5 genes, 209 species trees for 6 genes, 120 species trees for 7 genes, 45 species trees for 8 genes, 10 species trees for 9 genes, and 1 species trees for 10 genes. For each combination, a representative combination with the highest the MAST% and the common node correlation are shown in the Table 2. The best combination to use for the development of Ulva organellar universal markers should be the combination with the highest values of the two indices and the lowest number of markers in the combination. The combination with five to eight markers has the highest value for the MAST% and the highest value for the common node correlation, but given the number of markers, it might pose more challenges for the development process later. The combination with four markers, psbD, psaA, cox1, cox2, which also has the highest value for the MAST% and has the value for the common node correlation slightly lower than the highest value, is chosen for the next step. This combination comprises of two cp genes, psbD, psaA, and two mt genes, cox1, cox2.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Species tree reconstruction from organellar genomes</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-phylogeny-reconstruction.html#sec-lesson-learnt-cp-and-mt-phylogeny-reconstruction",
    "href": "cp-and-mt-phylogeny-reconstruction.html#sec-lesson-learnt-cp-and-mt-phylogeny-reconstruction",
    "title": "2  Species tree reconstruction from organellar genomes",
    "section": "2.3 Lessons Learnt",
    "text": "2.3 Lessons Learnt\nSo far, we have learnt:\n\nTCGA is a public resource with a wide collection of samples from cancer biopsies from patients affected by 32 different cancer types.\nTCGA provides abundant molecular and clinical information for both biopsies and patients and it allows for patient stratification and therapeutic target discovery.\nCancers with kidneys as primary sites are the third most abundant samples available in TCGA (n = 1,030 samples), after breast (n = 1,246) and lung biopsies (n = 1,156), and provides an excellent yet challenging case-study.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Species tree reconstruction from organellar genomes</span>"
    ]
  },
  {
    "objectID": "cp-and-mt-phylogeny-reconstruction.html#session-information",
    "href": "cp-and-mt-phylogeny-reconstruction.html#session-information",
    "title": "2  Species tree reconstruction from organellar genomes",
    "section": "2.4 Session Information",
    "text": "2.4 Session Information\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-conda-linux-gnu (64-bit)\nRunning under: openSUSE Tumbleweed\n\nMatrix products: default\nBLAS/LAPACK: /home/andrea/miniforge3/envs/moai/lib/libmkl_rt.so.2;  LAPACK version 3.9.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=it_IT.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Europe/Brussels\ntzcode source: system (glibc)\n\nattached base packages:\n [1] parallel  stats4    grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] treeio_1.26.0         TreeDist_2.9.2        stringr_1.5.1        \n [4] scales_1.3.0          RColorBrewer_1.1-3    reshape_0.8.9        \n [7] phytools_2.4-4        maps_3.4.2.1          phylogram_2.1.0      \n[10] phangorn_2.12.1       gridExtra_2.3         ggtree_3.10.1        \n[13] ggplot2_3.5.1         ggdist_3.3.2          doSNOW_1.0.20        \n[16] snow_0.4-4            iterators_1.0.14      foreach_1.5.2        \n[19] dendextend_1.19.0     DECIPHER_2.30.0       RSQLite_2.3.9        \n[22] Biostrings_2.70.3     GenomeInfoDb_1.38.8   XVector_0.42.0       \n[25] IRanges_2.36.0        S4Vectors_0.40.2      BiocGenerics_0.48.1  \n[28] corrplot_0.95         ComplexHeatmap_2.18.0 circlize_0.4.16      \n[31] ape_5.8-1            \n\nloaded via a namespace (and not attached):\n  [1] jsonlite_1.8.9          shape_1.4.6.1           magrittr_2.0.3         \n  [4] farver_2.1.2            rmarkdown_2.29          GlobalOptions_0.1.2    \n  [7] fs_1.6.5                zlibbioc_1.48.2         vctrs_0.6.5            \n [10] memoise_2.0.1           RCurl_1.98-1.16         htmltools_0.5.8.1      \n [13] distributional_0.5.0    DEoptim_2.2-8           gridGraphics_0.5-1     \n [16] htmlwidgets_1.6.4       plyr_1.8.9              cachem_1.1.0           \n [19] igraph_2.1.4            mime_0.12               lifecycle_1.0.4        \n [22] pkgconfig_2.0.3         Matrix_1.6-5            R6_2.5.1               \n [25] fastmap_1.2.0           GenomeInfoDbData_1.2.11 rbibutils_2.3          \n [28] shiny_1.10.0            clue_0.3-66             digest_0.6.37          \n [31] numDeriv_2016.8-1.1     aplot_0.2.4             ggnewscale_0.5.0       \n [34] colorspace_2.1-1        patchwork_1.3.0         labeling_0.4.3         \n [37] clusterGeneration_1.3.8 compiler_4.3.2          bit64_4.6.0-1          \n [40] withr_3.0.2             doParallel_1.0.17       optimParallel_1.0-2    \n [43] viridis_0.6.5           DBI_1.2.3               R.utils_2.12.3         \n [46] MASS_7.3-60.0.1         rjson_0.2.23            scatterplot3d_0.3-44   \n [49] tools_4.3.2             httpuv_1.6.15           TreeTools_1.13.0       \n [52] R.oo_1.27.0             glue_1.8.0              quadprog_1.5-8         \n [55] nlme_3.1-167            R.cache_0.16.0          promises_1.3.2         \n [58] cluster_2.1.8           PlotTools_0.3.1         generics_0.1.3         \n [61] gtable_0.3.6            R.methodsS3_1.8.2       tidyr_1.3.1            \n [64] pillar_1.10.1           yulab.utils_0.2.0       later_1.4.1            \n [67] dplyr_1.1.4             lattice_0.22-6          bit_4.5.0.1            \n [70] tidyselect_1.2.1        knitr_1.49              xfun_0.50              \n [73] expm_1.0-0              matrixStats_1.5.0       stringi_1.8.4          \n [76] lazyeval_0.2.2          ggfun_0.1.8             yaml_2.3.10            \n [79] evaluate_1.0.3          codetools_0.2-20        tibble_3.2.1           \n [82] ggplotify_0.1.2         cli_3.6.3               xtable_1.8-4           \n [85] Rdpack_2.6.2            munsell_0.5.1           Rcpp_1.0.14            \n [88] coda_0.19-4.1           png_0.1-8               blob_1.2.4             \n [91] bitops_1.0-9            viridisLite_0.4.2       tidytree_0.4.6         \n [94] purrr_1.0.2             crayon_1.5.3            combinat_0.0-8         \n [97] GetoptLong_1.0.5        rlang_1.1.5             fastmatch_1.1-6        \n[100] mnormt_2.1.1            shinyjs_2.1.0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Species tree reconstruction from organellar genomes</span>"
    ]
  },
  {
    "objectID": "markers-selection.html",
    "href": "markers-selection.html",
    "title": "3  Gene markers selection",
    "section": "",
    "text": "3.1 On this page\nBiological insights and take-home messages are at the bottom of the page at Lesson Learnt: Section 3.4.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Gene markers selection</span>"
    ]
  },
  {
    "objectID": "markers-selection.html#on-this-page",
    "href": "markers-selection.html#on-this-page",
    "title": "3  Gene markers selection",
    "section": "",
    "text": "Here we focus on samples from Kidney Cancers patients and their overall relationships.\nWe then explore the association between each Kidney Cancer subtype and the major clinical covariates (e.g.: sex, disease status, cancer stage, clinical outcome).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Gene markers selection</span>"
    ]
  },
  {
    "objectID": "markers-selection.html#organellar-gene-selection",
    "href": "markers-selection.html#organellar-gene-selection",
    "title": "3  Gene markers selection",
    "section": "3.2 Organellar gene selection",
    "text": "3.2 Organellar gene selection\nselect genes based on their distance to the reconstructed CP+MT phylogenetic three\nwe select only 10 genes (6 cp and 4 mt) because doing the combination with all the 99 genes wilñl take forever\n\n3.2.1 gene distances to species three\nWe take cp+mt ML tree as the real species tree for Ulva. Let’s now calculate the distance between each gene-tree and the species tree that we have reconstructed. Then, we can chose the top 5-10 genes that are closer to the reconstructed species tree to see what is their minimal combination able to reconstruct the gene tree.\n\n# get cp ML gene trees\ncp_ML_genes = list()\nfilenames = list.files(\"./03_cp_singleGene_ML/\", pattern = \"*.contree\", full.names = TRUE)\ncp_ML_genes = lapply(filenames, ape::read.tree)\nnames(cp_ML_genes) = strigr::str_remove_all(filenames, \"./03_cp_singleGene_ML//\")\nnames(cp_ML_genes) = strigr::str_remove_all(filenames, \".aln.contree\")\ncp_ML_genes[[\"cp_mt_ML\"]] = phylogenetic_trees[[\"cp_mt_ML\"]][[\"tree\"]]\n\n# get mt ML gene trees\nmt_ML_genes = list()\nfilenames = list.files(\"./03_mt_singleGene_ML/\", pattern = \"*.contree\", full.names = TRUE)\nmt_ML_genes = lapply(filenames, ape::read.tree)\nnames(mt_ML_genes) = strigr::str_remove_all(filenames, \"./03_mt_singleGene_ML//\")\nnames(mt_ML_genes) = strigr::str_remove_all(filenames, \".aln.contree\")\nmt_ML_genes[[\"cp_mt_ML\"]] = phylogenetic_trees[[\"cp_mt_ML\"]][[\"tree\"]]\n\n# create distance lists\ngenes_sets = list(\"cp_mt_ML\" = c(cp_ML_genes, mt_ML_genes[which(names(mt_ML_genes) != \"cp_mt_ML\")]))\n\nempty_matrix = matrix(nrow = length(genes_sets[[\"cp_mt_ML\"]]), ncol = length(genes_sets[[\"cp_mt_ML\"]]))\ncolnames(empty_matrix) = names(genes_sets[[\"cp_mt_ML\"]])\nrownames(empty_matrix) = names(genes_sets[[\"cp_mt_ML\"]])\ncp_mt_genes_distances = list(\n  \"common_nodes_corr\" = empty_matrix,\n  \"RF\" = empty_matrix,\n  \"KF\" = empty_matrix,\n  \"MAST_%\" = empty_matrix\n)\n\n# populate distances lists\ndistance_sets = list(\"cp_mt_genes_distances\" = cp_mt_genes_distances)\n\n# get pairwise distances\nfor(j in 1:length(distance_sets)){\n  for(i in 1:length(genes_sets[[j]])){\n    for(k in 1:length(genes_sets[[j]])){\n      \n      # error handling\n      # MAST call errors for very unresulved trees (e.g.: psaM)\n      #   Error in root.phylo(x, bipart_x, resolve.root = TRUE) : \n      #   the specified outgroup is not monophyletic\n      # catch error and move forward\n      skip_to_next = FALSE\n      \n      # get tree\n      tree1_tmp = genes_sets[[j]][[i]]\n      tree2_tmp = genes_sets[[j]][[k]]\n      \n      # list of common species\n      species_list = tree1_tmp$tip.label[which(tree1_tmp$tip.label %in% tree2_tmp$tip.label)]\n      \n      # get overlapping species\n      tree1 = ape::keep.tip(tree1_tmp, species_list)\n      tree2 = ape::keep.tip(tree2_tmp, species_list)\n      \n      # get distances\n      distances = phangorn::treedist(tree1, tree2)\n      distance_sets[[j]][[\"RF\"]][i, k] = distances[[1]]\n      distance_sets[[j]][[\"KF\"]][i, k] = distances[[2]]\n      #dist_DB_pairwise[[\"path_diff\"]][i, k] = distances[[3]]\n      distance_sets[[j]][[\"MAST_%\"]][i, k] = tryCatch(\n        length(phangorn::mast(tree1, tree2, tree = FALSE)) / length(species_list),\n        error = function(e) { skip_to_next &lt;&lt;- TRUE }\n      )\n      \n      # error handling\n      if(skip_to_next){distance_sets[[j]][[\"MAST_%\"]][i, k] = NA}\n      \n    }\n  }\n}\n\n\n### get pairwise common_nodes_corr distances\n\n# create CPU cluster\ncl = parallel::makeCluster(8, type = \"SOCK\")\nregisterDoSNOW(cl)\n\n# get chronos in parallel\nchronos_list = foreach(k = 1:length(genes_sets[[\"cp_mt_ML\"]]), .combine = \"c\") %dopar% {\n  library(\"ape\")\n  # get tree\n  tryCatch(chronos(genes_sets[[\"cp_mt_ML\"]][[k]]), error = function(e) { NA })\n}  \nparallel::stopCluster(cl)\nnames(chronos_list) = names(genes_sets[[\"cp_mt_ML\"]])\n\n# get pairwise common_nodes_corr distances\nfor(j in 1:length(distance_sets)){\n  for(i in 1:length(genes_sets[[j]])){\n    for(k in 1:length(genes_sets[[j]])){\n      \n      # get trees\n      tree1_tmp = chronos_list[[names(genes_sets[[j]])[i]]]\n      tree2_tmp = chronos_list[[names(genes_sets[[j]])[k]]]\n      \n      # check trees and get distance\n      if(all(!is.na(tree1_tmp)) & all(!is.na(tree2_tmp))){\n        distance_sets[[j]][[\"common_nodes_corr\"]][i, k] = cor.dendlist(\n          dendlist(as.dendrogram(tree1_tmp), as.dendrogram(tree2_tmp)),\n          method = \"common_nodes\")[2]\n      } else {\n        distance_sets[[j]][[\"common_nodes_corr\"]][i, k] = NA\n      }\n    }\n  }\n}\n\n\n# rename matrices for cp/mt overlapping rpl/rps genes (for plotting reasons)\nfor(i in 1:length(distance_sets[[\"cp_mt_genes_distances\"]])){\n  \n  rownames(distance_sets[[\"cp_mt_genes_distances\"]][[i]]) = c(\n    \"accD\", \"atpA\", \"atpB\", \"atpE\", \"atpF\", \"atpH\", \"atpI\", \"ccsA\", \"cemA\", \"chlI\", \"clpP\",\n    \"infA\", \"petA\", \"petB\", \"petD\", \"petG\", \"petL\", \"psaA\", \"psaB\", \"psaC\", \"psaI\", \"psaJ\",\n    \"psaM\", \"psbA\", \"psbB\", \"psbC\", \"psbD\", \"psbE\", \"psbF\", \"psbH\", \"psbI\", \"psbJ\", \"psbK\",\n    \"psbL\", \"psbM\", \"psbN\", \"psbT\", \"psbZ\", \"rbcL\", \"rpl12\", \"rpl14\", \"rpl16\", \"rpl19\", \"rpl2\",\n    \"rpl20\", \"rpl23\", \"rpl32\", \"rpl36\", \"rpl5\", \"rpoA\", \"rpoB\", \"rpoC1\", \"rpoC2\", \"rps11\",\n    \"rps12\", \"rps14\", \"rps18\", \"rps19\", \"rps2\", \"rps3\",  \"rps4\", \"rps7\", \"rps8\", \"rps9\",\n    \"tufA\", \"ycf1\", \"ycf12\", \"ycf20\", \"ycf3\", \"ycf4\", \"cp_mt_ML\", \"atp1\", \"atp4\", \"atp6\",\n    \"atp8\", \"atp9\", \"cob\", \"cox1\", \"cox2\", \"cox3\", \"nad1\", \"nad2\", \"nad3\", \"nad4\", \"nad4L\",\n    \"nad5\", \"nad6\", \"nad7\", \"rpl14 \", \"rpl16 \", \"rpl5 \", \"rps10\", \"rps11 \", \"rps12 \", \"rps13\",\n    \"rps14 \", \"rps19 \", \"rps2 \", \"rps3 \", \"rps4 \"\n  )\n  \n  colnames(distance_sets[[\"cp_mt_genes_distances\"]][[i]]) = c(\n    \"accD\", \"atpA\", \"atpB\", \"atpE\", \"atpF\", \"atpH\", \"atpI\", \"ccsA\", \"cemA\", \"chlI\", \"clpP\",\n    \"infA\", \"petA\", \"petB\", \"petD\", \"petG\", \"petL\", \"psaA\", \"psaB\", \"psaC\", \"psaI\", \"psaJ\",\n    \"psaM\", \"psbA\", \"psbB\", \"psbC\", \"psbD\", \"psbE\", \"psbF\", \"psbH\", \"psbI\", \"psbJ\", \"psbK\",\n    \"psbL\", \"psbM\", \"psbN\", \"psbT\", \"psbZ\", \"rbcL\", \"rpl12\", \"rpl14\", \"rpl16\", \"rpl19\", \"rpl2\",\n    \"rpl20\", \"rpl23\", \"rpl32\", \"rpl36\", \"rpl5\", \"rpoA\", \"rpoB\", \"rpoC1\", \"rpoC2\", \"rps11\",\n    \"rps12\", \"rps14\", \"rps18\", \"rps19\", \"rps2\", \"rps3\",  \"rps4\", \"rps7\", \"rps8\", \"rps9\",\n    \"tufA\", \"ycf1\", \"ycf12\", \"ycf20\", \"ycf3\", \"ycf4\", \"cp_mt_ML\", \"atp1\", \"atp4\", \"atp6\",\n    \"atp8\", \"atp9\", \"cob\", \"cox1\", \"cox2\", \"cox3\", \"nad1\", \"nad2\", \"nad3\", \"nad4\", \"nad4L\",\n    \"nad5\", \"nad6\", \"nad7\", \"rpl14 \", \"rpl16 \", \"rpl5 \", \"rps10\", \"rps11 \", \"rps12 \", \"rps13\",\n    \"rps14 \", \"rps19 \", \"rps2 \", \"rps3 \", \"rps4 \"\n  )\n  \n}\n\nLet’s now plot the generated distances!\n\nCorrelation of the common nodesRobinson–Foulds distanceKuhner-Felsenstein distanceMaximum Agreement SubTree (MAST %)\n\n\n\n#!/usr/bin/env R\n\n# prepare gene lists\ncp_genes_list = c(\n  \"accD\", \"atpA\", \"atpB\", \"atpE\", \"atpF\", \"atpH\", \"atpI\", \"ccsA\", \"cemA\", \"chlI\", \"clpP\",\n  \"infA\", \"petA\", \"petB\", \"petD\", \"petG\", \"petL\", \"psaA\", \"psaB\", \"psaC\", \"psaI\", \"psaJ\",\n  \"psaM\", \"psbA\", \"psbB\", \"psbC\", \"psbD\", \"psbE\", \"psbF\", \"psbH\", \"psbI\", \"psbJ\", \"psbK\",\n  \"psbL\", \"psbM\", \"psbN\", \"psbT\", \"psbZ\", \"rbcL\", \"rpl12\", \"rpl14\", \"rpl16\", \"rpl19\", \"rpl2\",\n  \"rpl20\", \"rpl23\", \"rpl32\", \"rpl36\", \"rpl5\", \"rpoA\", \"rpoB\", \"rpoC1\", \"rpoC2\", \"rps11\",\n  \"rps12\", \"rps14\", \"rps18\", \"rps19\", \"rps2\", \"rps3\",  \"rps4\", \"rps7\", \"rps8\", \"rps9\",\n  \"tufA\", \"ycf1\", \"ycf12\", \"ycf20\", \"ycf3\", \"ycf4\"\n)\n\nmt_genes_list = c(\n  \"atp1\", \"atp4\", \"atp6\", \"atp8\", \"atp9\", \"cob\", \"cox1\", \"cox2\", \"cox3\", \"nad1\", \"nad2\",\n  \"nad3\", \"nad4\", \"nad4L\", \"nad5\", \"nad6\", \"nad7\", \"rpl14 \", \"rpl16 \", \"rpl5 \", \"rps10\",\n  \"rps11 \", \"rps12 \", \"rps13\", \"rps14 \", \"rps19 \", \"rps2 \", \"rps3 \", \"rps4 \"\n)\n\n# remove possible rows/columns with only NAs\ntmp_matrix = distance_sets[[\"cp_mt_genes_distances\"]][[\"common_nodes_corr\"]]\ntmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) &lt; nrow(tmp_matrix)]\ntmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) &lt; ncol(tmp_matrix), ]\n\n# prep annotation\norganell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, \"cp\",\n                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, \"mt\", \"cp_mt\")) %&gt;%\n              as.data.frame()\nrownames(organell) = rownames(tmp_matrix)\ncolnames(organell) = \"organell\"\norganell$color = ifelse(organell$organell == \"cp\", \"#469d89\", ifelse(organell$organell == \"mt\", \"steelblue\", \"red\"))\n\n# plot raw distance\nComplexHeatmap::Heatmap(\n  tmp_matrix,\n  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),\n                   c(\"white\", \"steelblue\")),\n  row_names_gp = gpar(col = organell$color),\n  column_names_gp = gpar(col = organell$color),\n  top_annotation = HeatmapAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    show_legend = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  left_annotation = rowAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  name = \"common\\nnodes\\ncorr\"\n)\n\n\n\n\nFigure 1: cp + mt species tree reconstruction\n\n\n\n\n\n\n\n#!/usr/bin/env R\n\n\n# remove possible rows/columns with only NAs\ntmp_matrix = distance_sets[[\"cp_mt_genes_distances\"]][[\"RF\"]]\ntmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) &lt; nrow(tmp_matrix)]\ntmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) &lt; ncol(tmp_matrix), ]\n\n# prep annotation\norganell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, \"cp\",\n                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, \"mt\", \"cp_mt\")) %&gt;%\n              as.data.frame()\nrownames(organell) = rownames(tmp_matrix)\ncolnames(organell) = \"organell\"\norganell$color = ifelse(organell$organell == \"cp\", \"#469d89\", ifelse(organell$organell == \"mt\", \"steelblue\", \"red\"))\n\n# plot raw distance\nComplexHeatmap::Heatmap(\n  tmp_matrix,\n  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),\n                   c(\"white\", \"#D55E00\")),\n  row_names_gp = gpar(col = organell$color),\n  column_names_gp = gpar(col = organell$color),\n  top_annotation = HeatmapAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    show_legend = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  left_annotation = rowAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  name = \"Robinson–Foulds\"\n)\n\n\n\n\nFigure 1: cp + mt species tree reconstruction\n\n\n\n\n\n\n\n#!/usr/bin/env R\n\n\n# remove possible rows/columns with only NAs\ntmp_matrix = distance_sets[[\"cp_mt_genes_distances\"]][[\"KF\"]]\ntmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) &lt; nrow(tmp_matrix)]\ntmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) &lt; ncol(tmp_matrix), ]\n\n# prep annotation\norganell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, \"cp\",\n                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, \"mt\", \"cp_mt\")) %&gt;%\n              as.data.frame()\nrownames(organell) = rownames(tmp_matrix)\ncolnames(organell) = \"organell\"\norganell$color = ifelse(organell$organell == \"cp\", \"#469d89\", ifelse(organell$organell == \"mt\", \"steelblue\", \"red\"))\n\n# plot raw distance\nComplexHeatmap::Heatmap(\n  tmp_matrix,\n  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),\n                   c(\"white\", \"#D55E00\")),\n  row_names_gp = gpar(col = organell$color),\n  column_names_gp = gpar(col = organell$color),\n  top_annotation = HeatmapAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    show_legend = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  left_annotation = rowAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  name = \"Kuhner-Felsenstein\\ndistance\"\n)\n\n\n\n\nFigure 1: cp + mt species tree reconstruction\n\n\n\n\n\n\n\n#!/usr/bin/env R\n\n\n# remove possible rows/columns with only NAs\ntmp_matrix = distance_sets[[\"cp_mt_genes_distances\"]][[\"MAST_%\"]]\ntmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) &lt; nrow(tmp_matrix)]\ntmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) &lt; ncol(tmp_matrix), ]\n\n# prep annotation\norganell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, \"cp\",\n                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, \"mt\", \"cp_mt\")) %&gt;%\n              as.data.frame()\nrownames(organell) = rownames(tmp_matrix)\ncolnames(organell) = \"organell\"\norganell$color = ifelse(organell$organell == \"cp\", \"#469d89\", ifelse(organell$organell == \"mt\", \"steelblue\", \"red\"))\n\n# plot raw distance\nComplexHeatmap::Heatmap(\n  tmp_matrix,\n  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),\n                   c(\"white\", \"steelblue\")),\n  row_names_gp = gpar(col = organell$color),\n  column_names_gp = gpar(col = organell$color),\n  top_annotation = HeatmapAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    show_legend = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  left_annotation = rowAnnotation(\n    organell = as.matrix(organell$organell),\n    show_annotation_name = FALSE,\n    col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n  name = \"MAST_%\"\n)\n\n\n\n\nFigure 1: cp + mt species tree reconstruction\n\n\n\n\n\n\n\n\n\n        python3.10 combinatorial_ML_phylogeny.py --infolder \"ANALYSES_AND_RESULTS/\n09_combinatorial_phylogeny/00_cp_genes/,ANALYSES_AND_RESULTS/09_combinatorial_phylogeny/00_mt_genes/\" --names \"CP,MT\" --iqtree /home/Andrea/Desktop/ANALYSES_AND_RESULTS/bin/iqtree-2.2.0-Linux/bin/iqtree2 --n_genes 10 --outdir /home/Andrea/Desktop/CP_MT/ANALYSES_AND_RESULTS/09_combinatorial_phylogeny/\n\n\n### plot heatmaps of distances\n# prepare gene lists\ncp_genes_list = c(\"accD\", \"atpA\", \"atpB\", \"atpE\", \"atpF\", \"atpH\", \"atpI\", \"ccsA\", \"cemA\", \"chlI\", \"clpP\",\n                  \"infA\", \"petA\", \"petB\", \"petD\", \"petG\", \"petL\", \"psaA\", \"psaB\", \"psaC\", \"psaI\", \"psaJ\",\n                  \"psaM\", \"psbA\", \"psbB\", \"psbC\", \"psbD\", \"psbE\", \"psbF\", \"psbH\", \"psbI\", \"psbJ\", \"psbK\",\n                  \"psbL\", \"psbM\", \"psbN\", \"psbT\", \"psbZ\", \"rbcL\", \"rpl12\", \"rpl14\", \"rpl16\", \"rpl19\", \"rpl2\",\n                  \"rpl20\", \"rpl23\", \"rpl32\", \"rpl36\", \"rpl5\", \"rpoA\", \"rpoB\", \"rpoC1\", \"rpoC2\", \"rps11\",\n                  \"rps12\", \"rps14\", \"rps18\", \"rps19\", \"rps2\", \"rps3\",  \"rps4\", \"rps7\", \"rps8\", \"rps9\",\n                  \"tufA\", \"ycf1\", \"ycf12\", \"ycf20\", \"ycf3\", \"ycf4\")\nmt_genes_list = c(\"atp1\", \"atp4\", \"atp6\", \"atp8\", \"atp9\", \"cob\", \"cox1\", \"cox2\", \"cox3\", \"nad1\", \"nad2\",\n                  \"nad3\", \"nad4\", \"nad4L\", \"nad5\", \"nad6\", \"nad7\", \"rpl14 \", \"rpl16 \", \"rpl5 \", \"rps10\",\n                  \"rps11 \", \"rps12 \", \"rps13\", \"rps14 \", \"rps19 \", \"rps2 \", \"rps3 \", \"rps4 \")\n\n# prepare plot lists\ndistances_plots = list(\"cp\" = list(), \"mt\" = list(), \"cp_mt\" = list())\n\n# iterate plots\nfor(i in 1:length(distance_sets)){\n  for(k in 1:length(distance_sets[[i]])){\n    \n    # remove possible rows/columns with only NAs\n    tmp_matrix = distance_sets[[i]][[k]]\n    tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) &lt; nrow(tmp_matrix)]\n    tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) &lt; ncol(tmp_matrix), ]\n    \n    # get names\n    plot_name = ifelse(names(distance_sets[[i]])[[k]] == \"common_nodes_corr\", \"common\\nnodes\\ncorr\", names(distance_sets[[i]])[[k]])\n    \n    # prep annotation\n    organell = as.data.frame(ifelse(rownames(tmp_matrix) %in% cp_genes_list, \"cp\",\n                                    ifelse(rownames(tmp_matrix) %in% mt_genes_list, \"mt\", \"cp_mt\")))\n    rownames(organell) = rownames(tmp_matrix)\n    colnames(organell) = \"organell\"\n    organell$color = ifelse(organell$organell == \"cp\", \"#469d89\", ifelse(organell$organell == \"mt\", \"steelblue\", \"red\"))\n    \n    # plot raw distance\n    distances_plots[[i]][[k]] = grid.grabExpr(draw(ComplexHeatmap::Heatmap(tmp_matrix,\n                                                                           col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]),\n                                                                                              max(tmp_matrix[!is.na(tmp_matrix)])),\n                                                                                            c(\"white\", \"#D55E00\")),\n                                                                           row_names_gp = gpar(col = organell$color),\n                                                                           column_names_gp = gpar(col = organell$color),\n                                                                           top_annotation = HeatmapAnnotation(organell = as.matrix(organell$organell),\n                                                                                                              show_annotation_name = FALSE,\n                                                                                                              show_legend = FALSE,\n                                                                                                              col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n                                                                           left_annotation = rowAnnotation(organell = as.matrix(organell$organell),\n                                                                                                           show_annotation_name = FALSE,\n                                                                                                           col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n                                                                           name = plot_name)))\n    grid.newpage(recording = TRUE)\n    grid.draw(distances_plots[[i]][[k]])\n\n    # normalize\n    normalized = t(scale(t(tmp_matrix)))\n    # plot normalized distances\n    distances_plots[[i]][[k + 4]] = grid.grabExpr(draw(ComplexHeatmap::Heatmap(normalized,\n                                                                               col = colorRamp2(c(min(normalized[!is.na(normalized)]), 0, max(normalized[!is.na(normalized)])),\n                                                                                                c(\"#56B4E9\", \"white\", \"#D55E00\")),\n                                                                               row_names_gp = gpar(col = organell$color),\n                                                                               column_names_gp = gpar(col = organell$color),\n                                                                               top_annotation = HeatmapAnnotation(organell = as.matrix(organell$organell),\n                                                                                                                  show_annotation_name = FALSE,\n                                                                                                                  show_legend = FALSE,\n                                                                                                                  col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n                                                                               left_annotation = rowAnnotation(organell = as.matrix(organell$organell),\n                                                                                                               show_annotation_name = FALSE,\n                                                                                                               col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n                                                                               name = paste(plot_name, \"\\nz-score\", sep = \"\"))))\n    grid.newpage(recording = TRUE)\n    grid.draw(distances_plots[[i]][[k + 4]])\n  }\n}\n\n# composite plots\nfor(i in 1:length(distances_plots)){\n  grid.arrange(distances_plots[[i]][[1]], distances_plots[[i]][[2]],\n               distances_plots[[i]][[3]], distances_plots[[i]][[4]],\n               ncol = 2,\n               top = textGrob(paste(names(distances_plots)[i], \" raw distance\", sep = \"\")))\n  grid.arrange(distances_plots[[i]][[5]], distances_plots[[i]][[6]],\n               distances_plots[[i]][[7]], distances_plots[[i]][[8]],\n               ncol = 2,\n               top = textGrob(paste(names(distances_plots)[i], \" normalized distance\", sep = \"\")))\n  grid.arrange(distances_plots[[i]][[1]], distances_plots[[i]][[2]], distances_plots[[i]][[3]], distances_plots[[i]][[4]],\n               distances_plots[[i]][[5]], distances_plots[[i]][[6]], distances_plots[[i]][[7]], distances_plots[[i]][[8]],\n               ncol = 4,\n               top = textGrob(paste(names(distances_plots)[i], \" raw and normalized distance\", sep = \"\")))\n}\n\n# export tables\nfor(i in 1:length(distance_sets)){\n  for(k in 1:length(distance_sets[[i]])){\n    write.table(distance_sets[[i]][[k]],\n                file = paste(\"./08_genes_distances/\", names(distance_sets)[i], \".distances.\", names(distance_sets[[i]])[k], \".txt\", sep = \"\"),\n                quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n  }\n}\n\n# clean up\ncp_genes_distances = distance_sets[[\"cp_genes_distances\"]]\nmt_genes_distances = distance_sets[[\"mt_genes_distances\"]]\ncp_mt_genes_distances = distance_sets[[\"cp_mt_genes_distances\"]]\nrm(tree1_tmp, tree2_tmp, tree1, tree2, species_list, distances,\n   distance_sets, chronos_list, plot_name, tmp_matrix, genes_sets, skip_to_next)\n\n# close the pdf file\ndev.off()\n\n# export distance tables\nfor(i in 1:length(cp_genes_distances)){\n  write.table(cp_genes_distances[[i]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".04_Single_genes_stats.cp.\", names(cp_genes_distances)[i], \".txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n}\nfor(i in 1:length(mt_genes_distances)){\n  write.table(mt_genes_distances[[i]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".04_Single_genes_stats.mt.\", names(mt_genes_distances)[i], \".txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n}\nfor(i in 1:length(cp_mt_genes_distances)){\n  write.table(cp_mt_genes_distances[[i]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".04_Single_genes_stats.cp_mt.\", names(cp_mt_genes_distances)[i], \".txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n}\n\n\n3.3 Markers selection\nWe use a combinatorial approach to select the minimum list of genes to approxima te the CP+MT species three\n\n3.3.1 cp only\nss\n\n\n3.3.2 mt only\nss\n\n\n3.3.3 cp + mt\nss\n\n# declare gene lists\ncp_genes = c(\"petB\", \"psaA\", \"psaB\", \"psbB\", \"psbD\", \"rps2\")\nmt_genes = c(\"atp6\", \"cox1\", \"cox2\", \"rps3\")\n\n# import ref species tree\ncp_mt_ML_dendro = ape::read.tree(file = \"06_cp_mt_concat_ML/cp_mt_allgenes_concat.contree\")\n\n# create empty list of trees\ncombinatorial_trees = list(\"cp_mt_conc_2_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_3_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_4_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_5_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_6_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_7_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_8_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_9_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_10_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro))\n\n# populate combinatorial trees\nfor(k in 2:10){\n  \n  # get file list\n  tree_list_all = list.files(path = paste(mainDir, \"/09_combinatorial_phylogeny/01_cp_mt_combinatorial/cp_mt_conc_\", k, \"_genes\", sep = \"\"),\n                             pattern = \"\\\\.contree$\")\n  # keep only trees with both cp and mt markers\n  tree_list_fltr = c()\n  for(tree in tree_list_all){\n    cp = FALSE\n    mt = FALSE\n    # check if cp is present\n    for(gene in cp_genes){\n      if(grepl(gene, tree, fixed = TRUE)){\n        cp = TRUE\n      }\n    }\n    # check if mt is present\n    for(gene in mt_genes){\n      if(grepl(gene, tree, fixed = TRUE)){\n        mt = TRUE\n      }\n    }\n    if(cp == TRUE & mt == TRUE){\n      tree_list_fltr = c(tree_list_fltr, tree)\n    }\n  }\n  \n  # import trees\n  for(tree in tree_list_fltr){\n    combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]][[length(combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]]) + 1]] = ape::read.tree(file = paste(mainDir, \"/09_combinatorial_phylogeny/01_cp_mt_combinatorial/cp_mt_conc_\", k, \"_genes/\", tree, sep = \"\"))\n    names(combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]])[[length(combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]])]] = stringr::str_remove(tree, \".aln.contree\")\n  }\n  \n  # clean\n  rm(cp, gene, k, mt, tree, tree_list_all, tree_list_fltr)\n}\n\n\n\n#------------------------------------------------------------------------------#\n## 2.2 - Get distance matrices                                              ####\n\n# create distance lists\ncombinatorial_distances = list(\"cp_mt_conc_2_genes\" = NULL,\n                               \"cp_mt_conc_3_genes\" = NULL,\n                               \"cp_mt_conc_4_genes\" = NULL,\n                               \"cp_mt_conc_5_genes\" = NULL,\n                               \"cp_mt_conc_6_genes\" = NULL,\n                               \"cp_mt_conc_7_genes\" = NULL,\n                               \"cp_mt_conc_8_genes\" = NULL,\n                               \"cp_mt_conc_9_genes\" = NULL,\n                               \"cp_mt_conc_10_genes\" = NULL)\n\n# populate distance lists\ncombinatorial_list = c(25, 97, 195, 247, 210, 121, 46, 11, 2)\nfor(k in 1:length(combinatorial_distances)){\n  \n  # get size of the results matrix\n  empty_matrix = matrix(nrow = combinatorial_list[[k]],\n                        ncol = combinatorial_list[[k]])\n  colnames(empty_matrix) = names(combinatorial_trees[[k]])\n  rownames(empty_matrix) = names(combinatorial_trees[[k]])\n  \n  # populate\n  combinatorial_distances[[k]] = list(\"common_nodes_corr\" = empty_matrix,\n                                      \"RF\" = empty_matrix,\n                                      \"KF\" = empty_matrix,\n                                      \"MAST_%\" = empty_matrix)\n  \n  # clean\n  rm(empty_matrix)\n}\n\n# get pairwise distances\nfor(j in 1:length(combinatorial_trees)){\n  for(i in 1:length(combinatorial_trees[[j]])){\n    for(k in 1:length(combinatorial_trees[[j]])){\n      \n      # get tree\n      tree1_tmp = combinatorial_trees[[j]][[i]]\n      tree2_tmp = combinatorial_trees[[j]][[k]]\n\n      # list of common species\n      species_list = tree1_tmp$tip.label[which(tree1_tmp$tip.label %in% tree2_tmp$tip.label)]\n\n      # get overlapping species\n      tree1 = ape::keep.tip(tree1_tmp, species_list)\n      tree2 = ape::keep.tip(tree2_tmp, species_list)\n      \n      # get distances\n      distances = phangorn::treedist(tree1, tree2)\n      combinatorial_distances[[j]][[\"RF\"]][i, k] = distances[[1]]\n      combinatorial_distances[[j]][[\"KF\"]][i, k] = distances[[2]]\n      combinatorial_distances[[j]][[\"MAST_%\"]][i, k] = length(phangorn::mast(tree1, tree2, tree = FALSE)) / length(species_list)\n      \n      # clean\n      rm(tree1, tree2, tree1_tmp, tree2_tmp, distances)\n    }\n  }\n}\n\n\n### get pairwise common_nodes_corr distances\n\n# iterate all combinatorial trees\nfor(j in 1:length(combinatorial_trees)){\n  \n  # create CPU cluster\n  cl = parallel::makeCluster(8, type = \"SOCK\")\n  doSNOW::registerDoSNOW(cl)\n  \n  # get chronos in parallel\n  chronos_list = foreach(k = 1:length(combinatorial_trees[[j]]), .combine = \"c\") %dopar% {\n    library(\"ape\")\n    # get tree\n    tryCatch(chronos(combinatorial_trees[[j]][[k]]), error = function(e) { NA })\n  }  \n  parallel::stopCluster(cl)\n  names(chronos_list) = names(combinatorial_trees[[j]])\n  \n  # get pairwise common_nodes_corr distances\n  for(i in 1:length(combinatorial_trees[[j]])){\n    for(k in 1:length(combinatorial_trees[[j]])){\n      \n      print(paste(j, i, k, sep = \",\"))\n      \n      # get trees\n      tree1_tmp = chronos_list[[names(combinatorial_trees[[j]])[i]]]\n      tree2_tmp = chronos_list[[names(combinatorial_trees[[j]])[k]]]\n      \n      # check trees and get distance\n      if(all(!is.na(tree1_tmp)) & all(!is.na(tree2_tmp))){\n        combinatorial_distances[[j]][[\"common_nodes_corr\"]][i, k] = tryCatch(\n          cor.dendlist(dendlist(as.dendrogram(ape::root(tree1_tmp, outgroup = c(\"Oviri\", \"Pakin\"), resolve.root = TRUE)),\n                                as.dendrogram(ape::root(tree2_tmp, outgroup = c(\"Oviri\", \"Pakin\"), resolve.root = TRUE))),\n                       method = \"common_nodes\")[2],\n          error = function(e) { NA })\n      } else {\n        combinatorial_distances[[j]][[\"common_nodes_corr\"]][i, k] = NA\n      }\n    }\n  }\n}\n\n\n## export the distance matrices\nfor(i in 1:length(combinatorial_distances)){\n  write.table(combinatorial_distances[[i]][[\"common_nodes_corr\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.common_nodes_corr.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n  write.table(combinatorial_distances[[i]][[\"RF\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.RF.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n  write.table(combinatorial_distances[[i]][[\"KF\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.KF.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n  write.table(combinatorial_distances[[i]][[\"MAST_%\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.MAST_%.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n}\n\n\n\n#------------------------------------------------------------------------------#\n## 2.3 - Plot distance matrices                                             ####\n\n\n# \n# for(k in 1:length(combinatorial_distances)){\n#   \n#   # remove possible rows/columns with only NAs\n#   tmp_matrix = distance_sets[[i]][[k]]\n#   tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) &lt; nrow(tmp_matrix)]\n#   tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) &lt; ncol(tmp_matrix), ]\n#   \n#   # get names\n#   plot_name = ifelse(names(distance_sets[[i]])[[k]] == \"common_nodes_corr\", \"common\\nnodes\\ncorr\", names(distance_sets[[i]])[[k]])\n#   \n#   # prep annotation\n#   organell = as.data.frame(ifelse(rownames(tmp_matrix) %in% cp_genes_list, \"cp\",\n#                                   ifelse(rownames(tmp_matrix) %in% mt_genes_list, \"mt\", \"cp_mt\")))\n#   rownames(organell) = rownames(tmp_matrix)\n#   colnames(organell) = \"organell\"\n#   organell$color = ifelse(organell$organell == \"cp\", \"#469d89\", ifelse(organell$organell == \"mt\", \"steelblue\", \"red\"))\n#   \n#   # plot raw distance\n#   distances_plots[[i]][[k]] = grid.grabExpr(draw(ComplexHeatmap::Heatmap(tmp_matrix,\n#                                                                          col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]),\n#                                                                                             max(tmp_matrix[!is.na(tmp_matrix)])),\n#                                                                                           c(\"white\", \"#D55E00\")),\n#                                                                          row_names_gp = gpar(col = organell$color),\n#                                                                          column_names_gp = gpar(col = organell$color),\n#                                                                          top_annotation = HeatmapAnnotation(organell = as.matrix(organell$organell),\n#                                                                                                             show_annotation_name = FALSE,\n#                                                                                                             show_legend = FALSE,\n#                                                                                                             col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n#                                                                          left_annotation = rowAnnotation(organell = as.matrix(organell$organell),\n#                                                                                                          show_annotation_name = FALSE,\n#                                                                                                          col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n#                                                                          name = plot_name)))\n#   grid.newpage(recording = TRUE)\n#   grid.draw(distances_plots[[i]][[k]])\n# \n# \n# }\n\nTo resolve Ulva species phylogenetic relationships, supermatrix and coalescence-based phylogenetic approaches were applied to the chloroplast and mitochondrial datasets. To appreciate the different phylogenetic signals present in the two organellar datasets, the chloroplast and mitochondrial datasets were first analyzed independently. Afterwards, a supermatrix containing both chloroplast and mitochondrial genes was composed in order to infer the Ulva species phylogenetic tree. For the supermatrix Maximum-likelihood (ML) reconstruction, a gene-wise partitioned analysis was performed (Chernomor et al 2016). To estimate the best substitution model of each partition, ML trees were built with IQtree v.2.2.0 (Minh et al 2020) for each single-copy gene, inferring the best model and rate of heterogeneity across sites. All ML analyses were run with 1,000 ultra-fast bootstrap and SH-aLRT branch test replicates. Gene trees were used also for the coalescent-based analyses, using ASTRAL v5.7.8 (Zhang et al 2018), using the multilocus bootstrap support (MLBS) approach. 100 replicates were run (-r) starting from the 1,000 bootstrap trees generated for each gene during the ML analyses, allowing gene and site resampling (–gene-resampling flag). Four metrics were used to assess the concordance of the Ulva species tree reconstructed from supermatrix and coalescence-based analyses obtained from the analyses of chloroplast genes, mitochondrial genes and chloroplast and mitochondrial genes: Robinson-Foulds (Robinson & Foulds 1981), Kuhner-Felsenstein (Kuhner & Felsenstein 1994), Maximum Agreement Subtree (Finden & Gordon 1985) calculated with phangorn package (Schliep 2011), and correlation between the common nodes calculated with corr.dendlist function from dendexted package (Galili 2015). The RF distance measures the number of unique splits between two trees by comparing their bipartitions. It ranges from 0 (identical trees) to a higher value indicating greater dissimilarity with more unique splits (Robinson & Foulds 1981). The KF index quantifies the average genetic differences per site between populations, considering genetic variation within and between populations to provide a quantitative measure of genetic distance (Kuhner & Felsenstein 1994). The MAST (%) identifies the subset of nodes and branches that are common to both trees, disregarding any additional or missing branches. It aims to find the largest possible subtree that can be extracted from both trees while preserving their structural similarities, representing the maximum level of agreement in their branching patterns (Finden & Gordon 1985). The correlation between the common nodes is calculated as the pairwise cophenetic correlation coefficient between the distance matrix and the cophenetic matrix of the common nodes (Galili 2015). Both phangorn and dendextend packages are available in R statistical programming language (R Core Team 2022). Organellar gene ranking To identify the minimum number of genes (markers) necessary to reconstruct the Ulva species tree reconstructed with the 99 chloroplast and mitochondrial markers, Robinson-Foulds, Kuhner-Felsenstein, Maximum Agreement Subtree and correlation between the common nodes metrics were calculated between each of the 99 chloroplast and mitochondrial markers and the Ulva species tree reconstructed from supermatrix analysis. The same approach applied to the Ulva species trees reconstructed using chloroplast and mitochondrial supermatrix and coalesce-based analyses suggested that Maximum Agreement Subtree and common correlation nodes metrics are the best performers to assess phylogenetic tree distances when the tree do not have the same set of tips. The 10 markers (6 chloroplasts and 4 mitochondrial) with the best MAST% and common correlation nodes scores were arbitrarily chosen as candidates for the subsequent combinatorial phylogenetic analyses. Combinatorial phylogenetic analysis For the combinatorial phylogenetic analysis, a custom python script was used to exhaustively calculate the permutations between the chosen 10 marker genes, sampling between 2 and 10 markers. This resulted in the 945 unique combinations of at least a chloroplast and a mitochondrial marker (24 combinations of 2 marker genes, 96 of 3 markers, 194 of 4 markers, 246 of 5 markers, 209 of 6 markers, 120 of 7 markers, 45 of 8 markers, 10 of 9 markers and finally 1 containing all 10 markers genes). For each combination of markers, the script would then independently reconstruct the corresponding phylogenetic tree by invoking IQtree, inferring the best model and rate of heterogeneity across sites, with 1,000 ultra-fast bootstrap and SH-aLRT branch test replicates. Four metrics (RF, KF, MAST% and common correlation nodes scores) between each of the reconstructed 945 tree and the Ulva species tree reconstructed with the 99 chloroplast and mitochondrial markers were calculated in an iterative manner to identify the minimum set of chloroplast and mitochondrial markers necessary to reconstruct a ML phylogenetic tree concordant with the Ulva species tree reconstructed in this study. These markers are suggested to be used as a novel combination of markers to molecularly characterize Ulva species, and universal primers will be designed for each of the markers.\n\n\n\n3.4 Lessons Learnt\nSo far, we have learnt:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Gene markers selection</span>"
    ]
  },
  {
    "objectID": "markers-selection.html#markers-selection",
    "href": "markers-selection.html#markers-selection",
    "title": "3  Gene markers selection",
    "section": "3.3 Markers selection",
    "text": "3.3 Markers selection\nWe use a combinatorial approach to select the minimum list of genes to approxima te the CP+MT species three\n\n3.3.1 cp only\nss\n\n\n3.3.2 mt only\nss\n\n\n3.3.3 cp + mt\nss\n\n# declare gene lists\ncp_genes = c(\"petB\", \"psaA\", \"psaB\", \"psbB\", \"psbD\", \"rps2\")\nmt_genes = c(\"atp6\", \"cox1\", \"cox2\", \"rps3\")\n\n# import ref species tree\ncp_mt_ML_dendro = ape::read.tree(file = \"06_cp_mt_concat_ML/cp_mt_allgenes_concat.contree\")\n\n# create empty list of trees\ncombinatorial_trees = list(\"cp_mt_conc_2_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_3_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_4_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_5_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_6_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_7_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_8_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_9_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro),\n                           \"cp_mt_conc_10_genes\" = list(\"cp_mt_ML\" = cp_mt_ML_dendro))\n\n# populate combinatorial trees\nfor(k in 2:10){\n  \n  # get file list\n  tree_list_all = list.files(path = paste(mainDir, \"/09_combinatorial_phylogeny/01_cp_mt_combinatorial/cp_mt_conc_\", k, \"_genes\", sep = \"\"),\n                             pattern = \"\\\\.contree$\")\n  # keep only trees with both cp and mt markers\n  tree_list_fltr = c()\n  for(tree in tree_list_all){\n    cp = FALSE\n    mt = FALSE\n    # check if cp is present\n    for(gene in cp_genes){\n      if(grepl(gene, tree, fixed = TRUE)){\n        cp = TRUE\n      }\n    }\n    # check if mt is present\n    for(gene in mt_genes){\n      if(grepl(gene, tree, fixed = TRUE)){\n        mt = TRUE\n      }\n    }\n    if(cp == TRUE & mt == TRUE){\n      tree_list_fltr = c(tree_list_fltr, tree)\n    }\n  }\n  \n  # import trees\n  for(tree in tree_list_fltr){\n    combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]][[length(combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]]) + 1]] = ape::read.tree(file = paste(mainDir, \"/09_combinatorial_phylogeny/01_cp_mt_combinatorial/cp_mt_conc_\", k, \"_genes/\", tree, sep = \"\"))\n    names(combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]])[[length(combinatorial_trees[[paste(\"cp_mt_conc_\", k, \"_genes\", sep = \"\")]])]] = stringr::str_remove(tree, \".aln.contree\")\n  }\n  \n  # clean\n  rm(cp, gene, k, mt, tree, tree_list_all, tree_list_fltr)\n}\n\n\n\n#------------------------------------------------------------------------------#\n## 2.2 - Get distance matrices                                              ####\n\n# create distance lists\ncombinatorial_distances = list(\"cp_mt_conc_2_genes\" = NULL,\n                               \"cp_mt_conc_3_genes\" = NULL,\n                               \"cp_mt_conc_4_genes\" = NULL,\n                               \"cp_mt_conc_5_genes\" = NULL,\n                               \"cp_mt_conc_6_genes\" = NULL,\n                               \"cp_mt_conc_7_genes\" = NULL,\n                               \"cp_mt_conc_8_genes\" = NULL,\n                               \"cp_mt_conc_9_genes\" = NULL,\n                               \"cp_mt_conc_10_genes\" = NULL)\n\n# populate distance lists\ncombinatorial_list = c(25, 97, 195, 247, 210, 121, 46, 11, 2)\nfor(k in 1:length(combinatorial_distances)){\n  \n  # get size of the results matrix\n  empty_matrix = matrix(nrow = combinatorial_list[[k]],\n                        ncol = combinatorial_list[[k]])\n  colnames(empty_matrix) = names(combinatorial_trees[[k]])\n  rownames(empty_matrix) = names(combinatorial_trees[[k]])\n  \n  # populate\n  combinatorial_distances[[k]] = list(\"common_nodes_corr\" = empty_matrix,\n                                      \"RF\" = empty_matrix,\n                                      \"KF\" = empty_matrix,\n                                      \"MAST_%\" = empty_matrix)\n  \n  # clean\n  rm(empty_matrix)\n}\n\n# get pairwise distances\nfor(j in 1:length(combinatorial_trees)){\n  for(i in 1:length(combinatorial_trees[[j]])){\n    for(k in 1:length(combinatorial_trees[[j]])){\n      \n      # get tree\n      tree1_tmp = combinatorial_trees[[j]][[i]]\n      tree2_tmp = combinatorial_trees[[j]][[k]]\n\n      # list of common species\n      species_list = tree1_tmp$tip.label[which(tree1_tmp$tip.label %in% tree2_tmp$tip.label)]\n\n      # get overlapping species\n      tree1 = ape::keep.tip(tree1_tmp, species_list)\n      tree2 = ape::keep.tip(tree2_tmp, species_list)\n      \n      # get distances\n      distances = phangorn::treedist(tree1, tree2)\n      combinatorial_distances[[j]][[\"RF\"]][i, k] = distances[[1]]\n      combinatorial_distances[[j]][[\"KF\"]][i, k] = distances[[2]]\n      combinatorial_distances[[j]][[\"MAST_%\"]][i, k] = length(phangorn::mast(tree1, tree2, tree = FALSE)) / length(species_list)\n      \n      # clean\n      rm(tree1, tree2, tree1_tmp, tree2_tmp, distances)\n    }\n  }\n}\n\n\n### get pairwise common_nodes_corr distances\n\n# iterate all combinatorial trees\nfor(j in 1:length(combinatorial_trees)){\n  \n  # create CPU cluster\n  cl = parallel::makeCluster(8, type = \"SOCK\")\n  doSNOW::registerDoSNOW(cl)\n  \n  # get chronos in parallel\n  chronos_list = foreach(k = 1:length(combinatorial_trees[[j]]), .combine = \"c\") %dopar% {\n    library(\"ape\")\n    # get tree\n    tryCatch(chronos(combinatorial_trees[[j]][[k]]), error = function(e) { NA })\n  }  \n  parallel::stopCluster(cl)\n  names(chronos_list) = names(combinatorial_trees[[j]])\n  \n  # get pairwise common_nodes_corr distances\n  for(i in 1:length(combinatorial_trees[[j]])){\n    for(k in 1:length(combinatorial_trees[[j]])){\n      \n      print(paste(j, i, k, sep = \",\"))\n      \n      # get trees\n      tree1_tmp = chronos_list[[names(combinatorial_trees[[j]])[i]]]\n      tree2_tmp = chronos_list[[names(combinatorial_trees[[j]])[k]]]\n      \n      # check trees and get distance\n      if(all(!is.na(tree1_tmp)) & all(!is.na(tree2_tmp))){\n        combinatorial_distances[[j]][[\"common_nodes_corr\"]][i, k] = tryCatch(\n          cor.dendlist(dendlist(as.dendrogram(ape::root(tree1_tmp, outgroup = c(\"Oviri\", \"Pakin\"), resolve.root = TRUE)),\n                                as.dendrogram(ape::root(tree2_tmp, outgroup = c(\"Oviri\", \"Pakin\"), resolve.root = TRUE))),\n                       method = \"common_nodes\")[2],\n          error = function(e) { NA })\n      } else {\n        combinatorial_distances[[j]][[\"common_nodes_corr\"]][i, k] = NA\n      }\n    }\n  }\n}\n\n\n## export the distance matrices\nfor(i in 1:length(combinatorial_distances)){\n  write.table(combinatorial_distances[[i]][[\"common_nodes_corr\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.common_nodes_corr.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n  write.table(combinatorial_distances[[i]][[\"RF\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.RF.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n  write.table(combinatorial_distances[[i]][[\"KF\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.KF.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n  write.table(combinatorial_distances[[i]][[\"MAST_%\"]],\n              file = paste(\"UlvaOmics.\", format(Sys.Date(), format = \"%Y%m%d\"), \".05_combinatorial_stats.cp_mt_conc_\", i + 1, \"_genes.MAST_%.txt\",  sep = \"\"),\n              quote = FALSE, sep = '\\t', col.names = TRUE, row.names = TRUE)\n}\n\n\n\n#------------------------------------------------------------------------------#\n## 2.3 - Plot distance matrices                                             ####\n\n\n# \n# for(k in 1:length(combinatorial_distances)){\n#   \n#   # remove possible rows/columns with only NAs\n#   tmp_matrix = distance_sets[[i]][[k]]\n#   tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) &lt; nrow(tmp_matrix)]\n#   tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) &lt; ncol(tmp_matrix), ]\n#   \n#   # get names\n#   plot_name = ifelse(names(distance_sets[[i]])[[k]] == \"common_nodes_corr\", \"common\\nnodes\\ncorr\", names(distance_sets[[i]])[[k]])\n#   \n#   # prep annotation\n#   organell = as.data.frame(ifelse(rownames(tmp_matrix) %in% cp_genes_list, \"cp\",\n#                                   ifelse(rownames(tmp_matrix) %in% mt_genes_list, \"mt\", \"cp_mt\")))\n#   rownames(organell) = rownames(tmp_matrix)\n#   colnames(organell) = \"organell\"\n#   organell$color = ifelse(organell$organell == \"cp\", \"#469d89\", ifelse(organell$organell == \"mt\", \"steelblue\", \"red\"))\n#   \n#   # plot raw distance\n#   distances_plots[[i]][[k]] = grid.grabExpr(draw(ComplexHeatmap::Heatmap(tmp_matrix,\n#                                                                          col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]),\n#                                                                                             max(tmp_matrix[!is.na(tmp_matrix)])),\n#                                                                                           c(\"white\", \"#D55E00\")),\n#                                                                          row_names_gp = gpar(col = organell$color),\n#                                                                          column_names_gp = gpar(col = organell$color),\n#                                                                          top_annotation = HeatmapAnnotation(organell = as.matrix(organell$organell),\n#                                                                                                             show_annotation_name = FALSE,\n#                                                                                                             show_legend = FALSE,\n#                                                                                                             col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n#                                                                          left_annotation = rowAnnotation(organell = as.matrix(organell$organell),\n#                                                                                                          show_annotation_name = FALSE,\n#                                                                                                          col = list(organell = c(\"cp_mt\" = \"red\", \"cp\" = \"#469d89\", \"mt\" = \"steelblue\"))),\n#                                                                          name = plot_name)))\n#   grid.newpage(recording = TRUE)\n#   grid.draw(distances_plots[[i]][[k]])\n# \n# \n# }\n\nTo resolve Ulva species phylogenetic relationships, supermatrix and coalescence-based phylogenetic approaches were applied to the chloroplast and mitochondrial datasets. To appreciate the different phylogenetic signals present in the two organellar datasets, the chloroplast and mitochondrial datasets were first analyzed independently. Afterwards, a supermatrix containing both chloroplast and mitochondrial genes was composed in order to infer the Ulva species phylogenetic tree. For the supermatrix Maximum-likelihood (ML) reconstruction, a gene-wise partitioned analysis was performed (Chernomor et al 2016). To estimate the best substitution model of each partition, ML trees were built with IQtree v.2.2.0 (Minh et al 2020) for each single-copy gene, inferring the best model and rate of heterogeneity across sites. All ML analyses were run with 1,000 ultra-fast bootstrap and SH-aLRT branch test replicates. Gene trees were used also for the coalescent-based analyses, using ASTRAL v5.7.8 (Zhang et al 2018), using the multilocus bootstrap support (MLBS) approach. 100 replicates were run (-r) starting from the 1,000 bootstrap trees generated for each gene during the ML analyses, allowing gene and site resampling (–gene-resampling flag). Four metrics were used to assess the concordance of the Ulva species tree reconstructed from supermatrix and coalescence-based analyses obtained from the analyses of chloroplast genes, mitochondrial genes and chloroplast and mitochondrial genes: Robinson-Foulds (Robinson & Foulds 1981), Kuhner-Felsenstein (Kuhner & Felsenstein 1994), Maximum Agreement Subtree (Finden & Gordon 1985) calculated with phangorn package (Schliep 2011), and correlation between the common nodes calculated with corr.dendlist function from dendexted package (Galili 2015). The RF distance measures the number of unique splits between two trees by comparing their bipartitions. It ranges from 0 (identical trees) to a higher value indicating greater dissimilarity with more unique splits (Robinson & Foulds 1981). The KF index quantifies the average genetic differences per site between populations, considering genetic variation within and between populations to provide a quantitative measure of genetic distance (Kuhner & Felsenstein 1994). The MAST (%) identifies the subset of nodes and branches that are common to both trees, disregarding any additional or missing branches. It aims to find the largest possible subtree that can be extracted from both trees while preserving their structural similarities, representing the maximum level of agreement in their branching patterns (Finden & Gordon 1985). The correlation between the common nodes is calculated as the pairwise cophenetic correlation coefficient between the distance matrix and the cophenetic matrix of the common nodes (Galili 2015). Both phangorn and dendextend packages are available in R statistical programming language (R Core Team 2022). Organellar gene ranking To identify the minimum number of genes (markers) necessary to reconstruct the Ulva species tree reconstructed with the 99 chloroplast and mitochondrial markers, Robinson-Foulds, Kuhner-Felsenstein, Maximum Agreement Subtree and correlation between the common nodes metrics were calculated between each of the 99 chloroplast and mitochondrial markers and the Ulva species tree reconstructed from supermatrix analysis. The same approach applied to the Ulva species trees reconstructed using chloroplast and mitochondrial supermatrix and coalesce-based analyses suggested that Maximum Agreement Subtree and common correlation nodes metrics are the best performers to assess phylogenetic tree distances when the tree do not have the same set of tips. The 10 markers (6 chloroplasts and 4 mitochondrial) with the best MAST% and common correlation nodes scores were arbitrarily chosen as candidates for the subsequent combinatorial phylogenetic analyses. Combinatorial phylogenetic analysis For the combinatorial phylogenetic analysis, a custom python script was used to exhaustively calculate the permutations between the chosen 10 marker genes, sampling between 2 and 10 markers. This resulted in the 945 unique combinations of at least a chloroplast and a mitochondrial marker (24 combinations of 2 marker genes, 96 of 3 markers, 194 of 4 markers, 246 of 5 markers, 209 of 6 markers, 120 of 7 markers, 45 of 8 markers, 10 of 9 markers and finally 1 containing all 10 markers genes). For each combination of markers, the script would then independently reconstruct the corresponding phylogenetic tree by invoking IQtree, inferring the best model and rate of heterogeneity across sites, with 1,000 ultra-fast bootstrap and SH-aLRT branch test replicates. Four metrics (RF, KF, MAST% and common correlation nodes scores) between each of the reconstructed 945 tree and the Ulva species tree reconstructed with the 99 chloroplast and mitochondrial markers were calculated in an iterative manner to identify the minimum set of chloroplast and mitochondrial markers necessary to reconstruct a ML phylogenetic tree concordant with the Ulva species tree reconstructed in this study. These markers are suggested to be used as a novel combination of markers to molecularly characterize Ulva species, and universal primers will be designed for each of the markers.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Gene markers selection</span>"
    ]
  },
  {
    "objectID": "markers-selection.html#sec-lesson-learnt-markers-selection",
    "href": "markers-selection.html#sec-lesson-learnt-markers-selection",
    "title": "3  Gene markers selection",
    "section": "3.4 Lessons Learnt",
    "text": "3.4 Lessons Learnt\nSo far, we have learnt:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Gene markers selection</span>"
    ]
  }
]