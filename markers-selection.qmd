# Gene markers selection


```{css, echo=FALSE}

pre {
  max-height: 300px;
}

div.sourceCode {
  overflow: scroll;
}

.bash-code {
  font-style: italic;
}

```


```{r, echo=FALSE, include=FALSE}
# load required libraries
up_packages = c("ape", "circlize", "ComplexHeatmap", "corrplot", "DECIPHER", "dendextend", "doSNOW", "foreach",
                "ggdist", "ggplot2", "ggtree", "gridExtra", "phangorn", "phylogram", "phytools", "reshape",
                "RColorBrewer", "scales", "stringr", "TreeDist", "treeio")
lapply(up_packages, require, character.only = TRUE)

# set working directory
mainDir = "/home/andrea/19ADC99/UlvaOmics"
knitr::opts_knit$set(root.dir = mainDir)

# source custom functions
source("src/utils.R")
```




## On this page

Biological insights and take-home messages are at the bottom of the page at Lesson Learnt: @sec-lesson-learnt-markers-selection.

* Here we focus on samples from Kidney Cancers patients and their overall relationships.
* We then explore the association between each Kidney Cancer subtype and the major clinical covariates (e.g.: sex, disease status, cancer stage, clinical outcome).


## Organellar gene selection

select genes based on their distance to the reconstructed CP+MT phylogenetic three

we select only 10 genes (6 cp and 4 mt) because doing the combination with all the 99 genes wilñl take forever


### gene distances to species three


We take cp+mt ML tree as the real species tree for Ulva.
Let's now calculate the distance between each gene-tree and the species tree that we have reconstructed.
Then, we can chose the top 5-10 genes that are closer to the reconstructed species tree to see what is their minimal combination able to reconstruct the gene tree.


```{r}
#| echo: TRUE
#| eval: FALSE
#| result: hide
#| code-fold: FALSE
#| message: FALSE
#| warning: FALSE


# get cp ML gene trees
cp_ML_genes = list()
filenames = list.files("./03_cp_singleGene_ML/", pattern = "*.contree", full.names = TRUE)
cp_ML_genes = lapply(filenames, ape::read.tree)
names(cp_ML_genes) = strigr::str_remove_all(filenames, "./03_cp_singleGene_ML//")
names(cp_ML_genes) = strigr::str_remove_all(filenames, ".aln.contree")
cp_ML_genes[["cp_mt_ML"]] = phylogenetic_trees[["cp_mt_ML"]][["tree"]]

# get mt ML gene trees
mt_ML_genes = list()
filenames = list.files("./03_mt_singleGene_ML/", pattern = "*.contree", full.names = TRUE)
mt_ML_genes = lapply(filenames, ape::read.tree)
names(mt_ML_genes) = strigr::str_remove_all(filenames, "./03_mt_singleGene_ML//")
names(mt_ML_genes) = strigr::str_remove_all(filenames, ".aln.contree")
mt_ML_genes[["cp_mt_ML"]] = phylogenetic_trees[["cp_mt_ML"]][["tree"]]

# create distance lists
genes_sets = list("cp_mt_ML" = c(cp_ML_genes, mt_ML_genes[which(names(mt_ML_genes) != "cp_mt_ML")]))

empty_matrix = matrix(nrow = length(genes_sets[["cp_mt_ML"]]), ncol = length(genes_sets[["cp_mt_ML"]]))
colnames(empty_matrix) = names(genes_sets[["cp_mt_ML"]])
rownames(empty_matrix) = names(genes_sets[["cp_mt_ML"]])
cp_mt_genes_distances = list(
  "common_nodes_corr" = empty_matrix,
  "RF" = empty_matrix,
  "KF" = empty_matrix,
  "MAST_%" = empty_matrix
)

# populate distances lists
distance_sets = list("cp_mt_genes_distances" = cp_mt_genes_distances)

# get pairwise distances
for(j in 1:length(distance_sets)){
  for(i in 1:length(genes_sets[[j]])){
    for(k in 1:length(genes_sets[[j]])){
      
      # error handling
      # MAST call errors for very unresulved trees (e.g.: psaM)
      #   Error in root.phylo(x, bipart_x, resolve.root = TRUE) : 
      #   the specified outgroup is not monophyletic
      # catch error and move forward
      skip_to_next = FALSE
      
      # get tree
      tree1_tmp = genes_sets[[j]][[i]]
      tree2_tmp = genes_sets[[j]][[k]]
      
      # list of common species
      species_list = tree1_tmp$tip.label[which(tree1_tmp$tip.label %in% tree2_tmp$tip.label)]
      
      # get overlapping species
      tree1 = ape::keep.tip(tree1_tmp, species_list)
      tree2 = ape::keep.tip(tree2_tmp, species_list)
      
      # get distances
      distances = phangorn::treedist(tree1, tree2)
      distance_sets[[j]][["RF"]][i, k] = distances[[1]]
      distance_sets[[j]][["KF"]][i, k] = distances[[2]]
      #dist_DB_pairwise[["path_diff"]][i, k] = distances[[3]]
      distance_sets[[j]][["MAST_%"]][i, k] = tryCatch(
        length(phangorn::mast(tree1, tree2, tree = FALSE)) / length(species_list),
        error = function(e) { skip_to_next <<- TRUE }
      )
      
      # error handling
      if(skip_to_next){distance_sets[[j]][["MAST_%"]][i, k] = NA}
      
    }
  }
}


### get pairwise common_nodes_corr distances

# create CPU cluster
cl = parallel::makeCluster(8, type = "SOCK")
registerDoSNOW(cl)

# get chronos in parallel
chronos_list = foreach(k = 1:length(genes_sets[["cp_mt_ML"]]), .combine = "c") %dopar% {
  library("ape")
  # get tree
  tryCatch(chronos(genes_sets[["cp_mt_ML"]][[k]]), error = function(e) { NA })
}  
parallel::stopCluster(cl)
names(chronos_list) = names(genes_sets[["cp_mt_ML"]])

# get pairwise common_nodes_corr distances
for(j in 1:length(distance_sets)){
  for(i in 1:length(genes_sets[[j]])){
    for(k in 1:length(genes_sets[[j]])){
      
      # get trees
      tree1_tmp = chronos_list[[names(genes_sets[[j]])[i]]]
      tree2_tmp = chronos_list[[names(genes_sets[[j]])[k]]]
      
      # check trees and get distance
      if(all(!is.na(tree1_tmp)) & all(!is.na(tree2_tmp))){
        distance_sets[[j]][["common_nodes_corr"]][i, k] = cor.dendlist(
          dendlist(as.dendrogram(tree1_tmp), as.dendrogram(tree2_tmp)),
          method = "common_nodes")[2]
      } else {
        distance_sets[[j]][["common_nodes_corr"]][i, k] = NA
      }
    }
  }
}


# rename matrices for cp/mt overlapping rpl/rps genes (for plotting reasons)
for(i in 1:length(distance_sets[["cp_mt_genes_distances"]])){
  
  rownames(distance_sets[["cp_mt_genes_distances"]][[i]]) = c(
    "accD", "atpA", "atpB", "atpE", "atpF", "atpH", "atpI", "ccsA", "cemA", "chlI", "clpP",
    "infA", "petA", "petB", "petD", "petG", "petL", "psaA", "psaB", "psaC", "psaI", "psaJ",
    "psaM", "psbA", "psbB", "psbC", "psbD", "psbE", "psbF", "psbH", "psbI", "psbJ", "psbK",
    "psbL", "psbM", "psbN", "psbT", "psbZ", "rbcL", "rpl12", "rpl14", "rpl16", "rpl19", "rpl2",
    "rpl20", "rpl23", "rpl32", "rpl36", "rpl5", "rpoA", "rpoB", "rpoC1", "rpoC2", "rps11",
    "rps12", "rps14", "rps18", "rps19", "rps2", "rps3",  "rps4", "rps7", "rps8", "rps9",
    "tufA", "ycf1", "ycf12", "ycf20", "ycf3", "ycf4", "cp_mt_ML", "atp1", "atp4", "atp6",
    "atp8", "atp9", "cob", "cox1", "cox2", "cox3", "nad1", "nad2", "nad3", "nad4", "nad4L",
    "nad5", "nad6", "nad7", "rpl14 ", "rpl16 ", "rpl5 ", "rps10", "rps11 ", "rps12 ", "rps13",
    "rps14 ", "rps19 ", "rps2 ", "rps3 ", "rps4 "
  )
  
  colnames(distance_sets[["cp_mt_genes_distances"]][[i]]) = c(
    "accD", "atpA", "atpB", "atpE", "atpF", "atpH", "atpI", "ccsA", "cemA", "chlI", "clpP",
    "infA", "petA", "petB", "petD", "petG", "petL", "psaA", "psaB", "psaC", "psaI", "psaJ",
    "psaM", "psbA", "psbB", "psbC", "psbD", "psbE", "psbF", "psbH", "psbI", "psbJ", "psbK",
    "psbL", "psbM", "psbN", "psbT", "psbZ", "rbcL", "rpl12", "rpl14", "rpl16", "rpl19", "rpl2",
    "rpl20", "rpl23", "rpl32", "rpl36", "rpl5", "rpoA", "rpoB", "rpoC1", "rpoC2", "rps11",
    "rps12", "rps14", "rps18", "rps19", "rps2", "rps3",  "rps4", "rps7", "rps8", "rps9",
    "tufA", "ycf1", "ycf12", "ycf20", "ycf3", "ycf4", "cp_mt_ML", "atp1", "atp4", "atp6",
    "atp8", "atp9", "cob", "cox1", "cox2", "cox3", "nad1", "nad2", "nad3", "nad4", "nad4L",
    "nad5", "nad6", "nad7", "rpl14 ", "rpl16 ", "rpl5 ", "rps10", "rps11 ", "rps12 ", "rps13",
    "rps14 ", "rps19 ", "rps2 ", "rps3 ", "rps4 "
  )
  
}


```





```{r}
#| echo: FALSE
#| include: FALSE

#!/usr/bin/env R

# read distances lists
cp_mt_genes_distances = list(
  "common_nodes_corr" = utils::read.delim("./data/cp_mt.common_nodes_corr.txt", header = TRUE),
  "RF" = utils::read.delim("./data/cp_mt.RF.txt", header = TRUE),
  "KF" = utils::read.delim("./data/cp_mt.KF.txt", header = TRUE),
  "MAST_%" = utils::read.delim("./data/cp_mt.MAST_%.txt", header = TRUE)
)

distance_sets = list("cp_mt_genes_distances" = cp_mt_genes_distances)


```




Let's now plot the generated distances!



::: panel-tabset

#### Correlation of the common nodes


```{r}
#| echo: TRUE
#| result: hide
#| code-fold: FALSE
#| message: FALSE
#| warning: FALSE
#| fig.height: 6
#| fig.cap: "Figure 1: cp + mt species tree reconstruction"

#!/usr/bin/env R

# prepare gene lists
cp_genes_list = c(
  "accD", "atpA", "atpB", "atpE", "atpF", "atpH", "atpI", "ccsA", "cemA", "chlI", "clpP",
  "infA", "petA", "petB", "petD", "petG", "petL", "psaA", "psaB", "psaC", "psaI", "psaJ",
  "psaM", "psbA", "psbB", "psbC", "psbD", "psbE", "psbF", "psbH", "psbI", "psbJ", "psbK",
  "psbL", "psbM", "psbN", "psbT", "psbZ", "rbcL", "rpl12", "rpl14", "rpl16", "rpl19", "rpl2",
  "rpl20", "rpl23", "rpl32", "rpl36", "rpl5", "rpoA", "rpoB", "rpoC1", "rpoC2", "rps11",
  "rps12", "rps14", "rps18", "rps19", "rps2", "rps3",  "rps4", "rps7", "rps8", "rps9",
  "tufA", "ycf1", "ycf12", "ycf20", "ycf3", "ycf4"
)

mt_genes_list = c(
  "atp1", "atp4", "atp6", "atp8", "atp9", "cob", "cox1", "cox2", "cox3", "nad1", "nad2",
  "nad3", "nad4", "nad4L", "nad5", "nad6", "nad7", "rpl14 ", "rpl16 ", "rpl5 ", "rps10",
  "rps11 ", "rps12 ", "rps13", "rps14 ", "rps19 ", "rps2 ", "rps3 ", "rps4 "
)

# remove possible rows/columns with only NAs
tmp_matrix = distance_sets[["cp_mt_genes_distances"]][["common_nodes_corr"]]
tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) < nrow(tmp_matrix)]
tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) < ncol(tmp_matrix), ]

# prep annotation
organell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, "cp",
                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, "mt", "cp_mt")) %>%
              as.data.frame()
rownames(organell) = rownames(tmp_matrix)
colnames(organell) = "organell"
organell$color = ifelse(organell$organell == "cp", "#469d89", ifelse(organell$organell == "mt", "steelblue", "red"))

# plot raw distance
ComplexHeatmap::Heatmap(
  tmp_matrix,
  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),
                   c("white", "steelblue")),
  row_names_gp = gpar(col = organell$color),
  column_names_gp = gpar(col = organell$color),
  top_annotation = HeatmapAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    show_legend = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  left_annotation = rowAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  name = "common\nnodes\ncorr"
)

```


#### Robinson–Foulds distance


```{r}
#| echo: TRUE
#| result: hide
#| code-fold: FALSE
#| message: FALSE
#| warning: FALSE
#| fig.height: 6
#| fig.cap: "Figure 1: cp + mt species tree reconstruction"

#!/usr/bin/env R


# remove possible rows/columns with only NAs
tmp_matrix = distance_sets[["cp_mt_genes_distances"]][["RF"]]
tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) < nrow(tmp_matrix)]
tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) < ncol(tmp_matrix), ]

# prep annotation
organell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, "cp",
                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, "mt", "cp_mt")) %>%
              as.data.frame()
rownames(organell) = rownames(tmp_matrix)
colnames(organell) = "organell"
organell$color = ifelse(organell$organell == "cp", "#469d89", ifelse(organell$organell == "mt", "steelblue", "red"))

# plot raw distance
ComplexHeatmap::Heatmap(
  tmp_matrix,
  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),
                   c("white", "#D55E00")),
  row_names_gp = gpar(col = organell$color),
  column_names_gp = gpar(col = organell$color),
  top_annotation = HeatmapAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    show_legend = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  left_annotation = rowAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  name = "Robinson–Foulds"
)

```





#### Kuhner-Felsenstein distance


```{r}
#| echo: TRUE
#| result: hide
#| code-fold: FALSE
#| message: FALSE
#| warning: FALSE
#| fig.height: 6
#| fig.cap: "Figure 1: cp + mt species tree reconstruction"

#!/usr/bin/env R


# remove possible rows/columns with only NAs
tmp_matrix = distance_sets[["cp_mt_genes_distances"]][["KF"]]
tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) < nrow(tmp_matrix)]
tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) < ncol(tmp_matrix), ]

# prep annotation
organell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, "cp",
                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, "mt", "cp_mt")) %>%
              as.data.frame()
rownames(organell) = rownames(tmp_matrix)
colnames(organell) = "organell"
organell$color = ifelse(organell$organell == "cp", "#469d89", ifelse(organell$organell == "mt", "steelblue", "red"))

# plot raw distance
ComplexHeatmap::Heatmap(
  tmp_matrix,
  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),
                   c("white", "#D55E00")),
  row_names_gp = gpar(col = organell$color),
  column_names_gp = gpar(col = organell$color),
  top_annotation = HeatmapAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    show_legend = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  left_annotation = rowAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  name = "Kuhner-Felsenstein\ndistance"
)

```




#### Maximum Agreement SubTree (MAST %)


```{r}
#| echo: TRUE
#| result: hide
#| code-fold: FALSE
#| message: FALSE
#| warning: FALSE
#| fig.height: 6
#| fig.cap: "Figure 1: cp + mt species tree reconstruction"

#!/usr/bin/env R


# remove possible rows/columns with only NAs
tmp_matrix = distance_sets[["cp_mt_genes_distances"]][["MAST_%"]]
tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) < nrow(tmp_matrix)]
tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) < ncol(tmp_matrix), ]

# prep annotation
organell = ifelse(rownames(tmp_matrix) %in% cp_genes_list, "cp",
                  ifelse(rownames(tmp_matrix) %in% mt_genes_list, "mt", "cp_mt")) %>%
              as.data.frame()
rownames(organell) = rownames(tmp_matrix)
colnames(organell) = "organell"
organell$color = ifelse(organell$organell == "cp", "#469d89", ifelse(organell$organell == "mt", "steelblue", "red"))

# plot raw distance
ComplexHeatmap::Heatmap(
  tmp_matrix,
  col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]), max(tmp_matrix[!is.na(tmp_matrix)])),
                   c("white", "steelblue")),
  row_names_gp = gpar(col = organell$color),
  column_names_gp = gpar(col = organell$color),
  top_annotation = HeatmapAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    show_legend = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  left_annotation = rowAnnotation(
    organell = as.matrix(organell$organell),
    show_annotation_name = FALSE,
    col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
  name = "MAST_%"
)

```


:::



The top 10 single genes that produce similar ML tree topology to the Ulva species tree reconstructed from supermatrix analysis. The genes are ordered based on the decreasing values of the corresponding index.



```{r}
#| echo: FALSE
#| warning: FALSE

gene_table = data.frame(
  "rank" = seq(1, 10) %>% as.character(),
  "cp.RF" = c("psaA", "rpoC2", "rpoA", "rpoC1", "psaB", "psbB", "rps12", "ycf1", "chlI", "rps2"),
  "cp.MAST%" = c("psbB", "psaA", "rps2", "petB", "rpoC1", "psaB", "psbD", "rpl12", "rpoC2", "rpoA"),
  "cp.KF" = c("rpoA", "ycf20", "rpoB", "rpl32", "rps8", "accD", "atpF", "rps4", "rps9", "rpl2"),
  "cp.corr" = c("psaA", "psaB", "ycf1", "chlI", "rpoA", "psbB", "rpl19", "tufA", "rpoC1", "accD"),
  "mt.RF" = c("rps10", "rps3", "cox1", "rps2", "atp1", "atp6", "cox2", "nad4", "rps4", "nad2"),
  "mt.MAST%" = c("cox1", "cox2", "atp1", "cox3", "rps4", "rps2", "rps3", "cob", "rps19", "rps10"),
  "mt.KF" = c("rps3", "rps10", "rps2", "nad5", "nad7", "cox1", "rpl16", "rpl14", "rps14", "rps4"),
  "mt.corr" = c("cox2", "atp6", "cox3", "nad5", "rpl16", "rps11", "rps4", "nad2", "nad4", "cox1"),
  "cp_mt.RF" = c("psaA", "rpoC2", "rpoA", "rpoC1", "psaB", "psbB", "rps12", "ycf1", "chlI", "rps2"),
  "cp_mt.MAST%" = c("psbB", "psaA", "rps2", "cox1", "cox2", "petB", "rpoC1", "psaB", "psbD", "rpl12"),
  "cp_mt.KF" = c("mt_rps3", "mt_rps10", "rpoA", "mt_rps2", "nad5", "ycf20", "rpoB", "rpl32", "rps8", "accD"),
  "cp_mt.corr" = c("psaA", "psaB", "ycf1", "cox2", "chlI", "rpoA", "psbB", "rpl19", "tufA", "atp6")
)

# generate container with merged headers
sketch = htmltools::withTags(
  table(
    class = "display",
    thead(
      tr(
        th(rowspan = 2, "Rank"),
        th(colspan = 4, "chloroplast"),
        th(colspan = 4, "mitochondria"),
        th(colspan = 4, "chloroplast + mitochondria"),
      ),
      tr(
        lapply(rep(c("RF", "MAST %", "KF", "comm. node corr."), 3), th)
      )
    )
  )
)

# print gene table
DT::datatable(
  gene_table,
  container = sketch,
  rownames = FALSE,
  extensions = c("FixedColumns", "FixedHeader"),
  caption = "Table 1: top 10 genes closest to the reconstructed Ulva species tree.", 
  options = list(
    scrollX = TRUE, paging = TRUE, fixedHeader = FALSE, pageLength = 10
  )
)

```


Ide


Among the 70 cp genes chosen, the four indices RF, KF, MAST and the correlation between the common nodes metrics pointed out 24 unique cp genes that provide the most similar topology compared to the species tree constructed using 70 genes, namely accD, atpF, chlI, petB, psaA, psaB, psbB, psbD, rpl12, rpl19, rpl2, rpl32, rpoA, rpoB, rpoC1, rpoC2, rps12, rps2, rps4, rps8, rps9, tufA, ycf1, and ycf20 (Table 1). Among them, several genes such as psaA, psaB, and psbB are consistently identified by different matrices. Similarly, the same approach applied to the Ulva species trees reconstructed using mt suggested 19 unique mt genes, namely atp1, atp6, cob, cox1, cox2, cox3, nad2, nad4, nad5, nad7, rpl14, rpl16, rps10, rps11, rps14, rps19, rps2, rps3, and rps4, of which several genes such as atp6, cox1, cox2, rps3, and rps10 are suggested by different indices. Since the Ulva specimens used in this study do not always have both cp and mt genomes, the Ulva species trees reconstructed using cp and mt supermatrix have different set of tips, depending on the availability of the genomes. Prior analyses suggested that MAST% and common correlation nodes metrics are the best performers to assess phylogenetic tree distances when the tree do not have the same set of tips, we then selected (arbitrarily) 10 genes for the combinatorial approach, petB, psaA, psaB, psbB, psbD, rps2, atp6, cox1, cox2, and mt_rps3, based on the top 10 single gene ML trees with topology closest to cp_mt_ML. The first six genes are cp genes while the other four genes are mt genes. 




Table 1: The top 10 single genes that produce similar ML tree topology to the Ulva species tree reconstructed from supermatrix analysis. The genes are ordered based on the decreasing values of the corresponding index.

cp	cp_mt	mt
RF	MAST%	KF	cor	RF	MAST%	KF	cor	RF	MAST%	KF	cor
psaA	psbB	rpoA	psaA	psaA	psbB	mt_rps3	psaA	rps10	cox1	rps3	cox2
 rpoC2	 psaA	 ycf20	 psaB	 rpoC2	 psaA	 mt_rps10	 psaB	 rps3	 cox2	 rps10	 atp6
 rpoA	 rps2	 rpoB	 ycf1	 rpoA	 rps2	 rpoA	 ycf1	 cox1	 atp1	 rps2	 cox3
 rpoC1	 petB	 rpl32	 chlI	 rpoC1	 cox1	 mt_rps2	 cox2	 rps2	 cox3	 nad5	 nad5
 psaB	 rpoC1	 rps8	 rpoA	 psaB	 cox2	 nad5	 chlI	 atp1	 rps4	 nad7	 rpl16
 psbB	 psaB	 accD	 psbB	 psbB	 petB	 ycf20	 rpoA	 atp6	 rps2	 cox1	 rps11
 rps12	 psbD	 atpF	 rpl19	 rps12	 rpoC1	 rpoB	 psbB	 cox2	 rps3	 rpl16	 rps4
 ycf1	 rpl12	 rps4	 tufA	 ycf1	 psaB	 rpl32	 rpl19	 nad4	 cob	 rpl14	 nad2
 chlI	 rpoC2	 rps9	 rpoC1	 chlI	 psbD	 rps8	 tufA	 rps4	 rps19	 rps14	 nad4
 rps2	 rpoA	 rpl2	 accD	 rps2	 rpl12	 accD	 atp6	 nad2	 rps10	 rps4	 cox1

Ide













## Markers selection

We use a combinatorial approach to select the minimum list of genes to approxima te the CP+MT species three




cp_genes = c("petB", "psaA", "psaB", "psbB", "psbD", "rps2")
mt_genes = c("atp6", "cox1", "cox2", "rps3")



```{bash, eval=FALSE}




		python3.10 combinatorial_ML_phylogeny.py --infolder "ANALYSES_AND_RESULTS/
09_combinatorial_phylogeny/00_cp_genes/,ANALYSES_AND_RESULTS/09_combinatorial_phylogeny/00_mt_genes/" --names "CP,MT" --iqtree /home/Andrea/Desktop/ANALYSES_AND_RESULTS/bin/iqtree-2.2.0-Linux/bin/iqtree2 --n_genes 10 --outdir /home/Andrea/Desktop/CP_MT/ANALYSES_AND_RESULTS/09_combinatorial_phylogeny/

```






### cp only

ss


### mt only

ss

### cp + mt 

ss


```{r, eval=FALSE}


# declare gene lists
cp_genes = c("petB", "psaA", "psaB", "psbB", "psbD", "rps2")
mt_genes = c("atp6", "cox1", "cox2", "rps3")

# import ref species tree
cp_mt_ML_dendro = ape::read.tree(file = "06_cp_mt_concat_ML/cp_mt_allgenes_concat.contree")

# create empty list of trees
combinatorial_trees = list("cp_mt_conc_2_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_3_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_4_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_5_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_6_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_7_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_8_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_9_genes" = list("cp_mt_ML" = cp_mt_ML_dendro),
                           "cp_mt_conc_10_genes" = list("cp_mt_ML" = cp_mt_ML_dendro))

# populate combinatorial trees
for(k in 2:10){
  
  # get file list
  tree_list_all = list.files(path = paste(mainDir, "/09_combinatorial_phylogeny/01_cp_mt_combinatorial/cp_mt_conc_", k, "_genes", sep = ""),
                             pattern = "\\.contree$")
  # keep only trees with both cp and mt markers
  tree_list_fltr = c()
  for(tree in tree_list_all){
    cp = FALSE
    mt = FALSE
    # check if cp is present
    for(gene in cp_genes){
      if(grepl(gene, tree, fixed = TRUE)){
        cp = TRUE
      }
    }
    # check if mt is present
    for(gene in mt_genes){
      if(grepl(gene, tree, fixed = TRUE)){
        mt = TRUE
      }
    }
    if(cp == TRUE & mt == TRUE){
      tree_list_fltr = c(tree_list_fltr, tree)
    }
  }
  
  # import trees
  for(tree in tree_list_fltr){
    combinatorial_trees[[paste("cp_mt_conc_", k, "_genes", sep = "")]][[length(combinatorial_trees[[paste("cp_mt_conc_", k, "_genes", sep = "")]]) + 1]] = ape::read.tree(file = paste(mainDir, "/09_combinatorial_phylogeny/01_cp_mt_combinatorial/cp_mt_conc_", k, "_genes/", tree, sep = ""))
    names(combinatorial_trees[[paste("cp_mt_conc_", k, "_genes", sep = "")]])[[length(combinatorial_trees[[paste("cp_mt_conc_", k, "_genes", sep = "")]])]] = stringr::str_remove(tree, ".aln.contree")
  }
  
  # clean
  rm(cp, gene, k, mt, tree, tree_list_all, tree_list_fltr)
}



#------------------------------------------------------------------------------#
## 2.2 - Get distance matrices                                              ####

# create distance lists
combinatorial_distances = list("cp_mt_conc_2_genes" = NULL,
                               "cp_mt_conc_3_genes" = NULL,
                               "cp_mt_conc_4_genes" = NULL,
                               "cp_mt_conc_5_genes" = NULL,
                               "cp_mt_conc_6_genes" = NULL,
                               "cp_mt_conc_7_genes" = NULL,
                               "cp_mt_conc_8_genes" = NULL,
                               "cp_mt_conc_9_genes" = NULL,
                               "cp_mt_conc_10_genes" = NULL)

# populate distance lists
combinatorial_list = c(25, 97, 195, 247, 210, 121, 46, 11, 2)
for(k in 1:length(combinatorial_distances)){
  
  # get size of the results matrix
  empty_matrix = matrix(nrow = combinatorial_list[[k]],
                        ncol = combinatorial_list[[k]])
  colnames(empty_matrix) = names(combinatorial_trees[[k]])
  rownames(empty_matrix) = names(combinatorial_trees[[k]])
  
  # populate
  combinatorial_distances[[k]] = list("common_nodes_corr" = empty_matrix,
                                      "RF" = empty_matrix,
                                      "KF" = empty_matrix,
                                      "MAST_%" = empty_matrix)
  
  # clean
  rm(empty_matrix)
}

# get pairwise distances
for(j in 1:length(combinatorial_trees)){
  for(i in 1:length(combinatorial_trees[[j]])){
    for(k in 1:length(combinatorial_trees[[j]])){
      
      # get tree
      tree1_tmp = combinatorial_trees[[j]][[i]]
      tree2_tmp = combinatorial_trees[[j]][[k]]

      # list of common species
      species_list = tree1_tmp$tip.label[which(tree1_tmp$tip.label %in% tree2_tmp$tip.label)]

      # get overlapping species
      tree1 = ape::keep.tip(tree1_tmp, species_list)
      tree2 = ape::keep.tip(tree2_tmp, species_list)
      
      # get distances
      distances = phangorn::treedist(tree1, tree2)
      combinatorial_distances[[j]][["RF"]][i, k] = distances[[1]]
      combinatorial_distances[[j]][["KF"]][i, k] = distances[[2]]
      combinatorial_distances[[j]][["MAST_%"]][i, k] = length(phangorn::mast(tree1, tree2, tree = FALSE)) / length(species_list)
      
      # clean
      rm(tree1, tree2, tree1_tmp, tree2_tmp, distances)
    }
  }
}


### get pairwise common_nodes_corr distances

# iterate all combinatorial trees
for(j in 1:length(combinatorial_trees)){
  
  # create CPU cluster
  cl = parallel::makeCluster(8, type = "SOCK")
  doSNOW::registerDoSNOW(cl)
  
  # get chronos in parallel
  chronos_list = foreach(k = 1:length(combinatorial_trees[[j]]), .combine = "c") %dopar% {
    library("ape")
    # get tree
    tryCatch(chronos(combinatorial_trees[[j]][[k]]), error = function(e) { NA })
  }  
  parallel::stopCluster(cl)
  names(chronos_list) = names(combinatorial_trees[[j]])
  
  # get pairwise common_nodes_corr distances
  for(i in 1:length(combinatorial_trees[[j]])){
    for(k in 1:length(combinatorial_trees[[j]])){
      
      print(paste(j, i, k, sep = ","))
      
      # get trees
      tree1_tmp = chronos_list[[names(combinatorial_trees[[j]])[i]]]
      tree2_tmp = chronos_list[[names(combinatorial_trees[[j]])[k]]]
      
      # check trees and get distance
      if(all(!is.na(tree1_tmp)) & all(!is.na(tree2_tmp))){
        combinatorial_distances[[j]][["common_nodes_corr"]][i, k] = tryCatch(
          cor.dendlist(dendlist(as.dendrogram(ape::root(tree1_tmp, outgroup = c("Oviri", "Pakin"), resolve.root = TRUE)),
                                as.dendrogram(ape::root(tree2_tmp, outgroup = c("Oviri", "Pakin"), resolve.root = TRUE))),
                       method = "common_nodes")[2],
          error = function(e) { NA })
      } else {
        combinatorial_distances[[j]][["common_nodes_corr"]][i, k] = NA
      }
    }
  }
}


## export the distance matrices
for(i in 1:length(combinatorial_distances)){
  write.table(combinatorial_distances[[i]][["common_nodes_corr"]],
              file = paste("UlvaOmics.", format(Sys.Date(), format = "%Y%m%d"), ".05_combinatorial_stats.cp_mt_conc_", i + 1, "_genes.common_nodes_corr.txt",  sep = ""),
              quote = FALSE, sep = '\t', col.names = TRUE, row.names = TRUE)
  write.table(combinatorial_distances[[i]][["RF"]],
              file = paste("UlvaOmics.", format(Sys.Date(), format = "%Y%m%d"), ".05_combinatorial_stats.cp_mt_conc_", i + 1, "_genes.RF.txt",  sep = ""),
              quote = FALSE, sep = '\t', col.names = TRUE, row.names = TRUE)
  write.table(combinatorial_distances[[i]][["KF"]],
              file = paste("UlvaOmics.", format(Sys.Date(), format = "%Y%m%d"), ".05_combinatorial_stats.cp_mt_conc_", i + 1, "_genes.KF.txt",  sep = ""),
              quote = FALSE, sep = '\t', col.names = TRUE, row.names = TRUE)
  write.table(combinatorial_distances[[i]][["MAST_%"]],
              file = paste("UlvaOmics.", format(Sys.Date(), format = "%Y%m%d"), ".05_combinatorial_stats.cp_mt_conc_", i + 1, "_genes.MAST_%.txt",  sep = ""),
              quote = FALSE, sep = '\t', col.names = TRUE, row.names = TRUE)
}



#------------------------------------------------------------------------------#
## 2.3 - Plot distance matrices                                             ####


# 
# for(k in 1:length(combinatorial_distances)){
#   
#   # remove possible rows/columns with only NAs
#   tmp_matrix = distance_sets[[i]][[k]]
#   tmp_matrix = tmp_matrix[, colSums(is.na(tmp_matrix)) < nrow(tmp_matrix)]
#   tmp_matrix = tmp_matrix[rowSums(is.na(tmp_matrix)) < ncol(tmp_matrix), ]
#   
#   # get names
#   plot_name = ifelse(names(distance_sets[[i]])[[k]] == "common_nodes_corr", "common\nnodes\ncorr", names(distance_sets[[i]])[[k]])
#   
#   # prep annotation
#   organell = as.data.frame(ifelse(rownames(tmp_matrix) %in% cp_genes_list, "cp",
#                                   ifelse(rownames(tmp_matrix) %in% mt_genes_list, "mt", "cp_mt")))
#   rownames(organell) = rownames(tmp_matrix)
#   colnames(organell) = "organell"
#   organell$color = ifelse(organell$organell == "cp", "#469d89", ifelse(organell$organell == "mt", "steelblue", "red"))
#   
#   # plot raw distance
#   distances_plots[[i]][[k]] = grid.grabExpr(draw(ComplexHeatmap::Heatmap(tmp_matrix,
#                                                                          col = colorRamp2(c(min(tmp_matrix[!is.na(tmp_matrix)]),
#                                                                                             max(tmp_matrix[!is.na(tmp_matrix)])),
#                                                                                           c("white", "#D55E00")),
#                                                                          row_names_gp = gpar(col = organell$color),
#                                                                          column_names_gp = gpar(col = organell$color),
#                                                                          top_annotation = HeatmapAnnotation(organell = as.matrix(organell$organell),
#                                                                                                             show_annotation_name = FALSE,
#                                                                                                             show_legend = FALSE,
#                                                                                                             col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
#                                                                          left_annotation = rowAnnotation(organell = as.matrix(organell$organell),
#                                                                                                          show_annotation_name = FALSE,
#                                                                                                          col = list(organell = c("cp_mt" = "red", "cp" = "#469d89", "mt" = "steelblue"))),
#                                                                          name = plot_name)))
#   grid.newpage(recording = TRUE)
#   grid.draw(distances_plots[[i]][[k]])
# 
# 
# }


```






To resolve Ulva species phylogenetic relationships, supermatrix and coalescence-based phylogenetic approaches were applied to the chloroplast and mitochondrial datasets. To appreciate the different phylogenetic signals present in the two organellar datasets, the chloroplast and mitochondrial datasets were first analyzed independently. Afterwards, a supermatrix containing both chloroplast and mitochondrial genes was composed in order to infer the Ulva species phylogenetic tree.
For the supermatrix Maximum-likelihood (ML) reconstruction, a gene-wise partitioned analysis was performed (Chernomor et al 2016). To estimate the best substitution model of each partition, ML trees were built with IQtree v.2.2.0 (Minh et al 2020) for each single-copy gene, inferring the best model and rate of heterogeneity across sites. All ML analyses were run with 1,000 ultra-fast bootstrap and SH-aLRT branch test replicates.
Gene trees were used also for the coalescent-based analyses, using ASTRAL v5.7.8 (Zhang et al 2018), using the multilocus bootstrap support (MLBS) approach. 100 replicates were run (-r) starting from the 1,000 bootstrap trees generated for each gene during the ML analyses, allowing gene and site resampling (–gene-resampling flag).
Four metrics were used to assess the concordance of the Ulva species tree reconstructed from supermatrix and coalescence-based analyses obtained from the analyses of chloroplast genes, mitochondrial genes and chloroplast and mitochondrial genes: Robinson-Foulds (Robinson & Foulds 1981), Kuhner-Felsenstein (Kuhner & Felsenstein 1994), Maximum Agreement Subtree (Finden & Gordon 1985) calculated with phangorn package (Schliep 2011), and correlation between the common nodes calculated with corr.dendlist function from dendexted package (Galili 2015). The RF distance measures the number of unique splits between two trees by comparing their bipartitions. It ranges from 0 (identical trees) to a higher value indicating greater dissimilarity with more unique splits (Robinson & Foulds 1981). The KF index quantifies the average genetic differences per site between populations, considering genetic variation within and between populations to provide a quantitative measure of genetic distance (Kuhner & Felsenstein 1994). The MAST (%) identifies the subset of nodes and branches that are common to both trees, disregarding any additional or missing branches. It aims to find the largest possible subtree that can be extracted from both trees while preserving their structural similarities, representing the maximum level of agreement in their branching patterns (Finden & Gordon 1985). The correlation between the common nodes is calculated as the pairwise cophenetic correlation coefficient between the distance matrix and the cophenetic matrix of the common nodes (Galili 2015). Both phangorn and dendextend packages are available in R statistical programming language (R Core Team 2022).
Organellar gene ranking
To identify the minimum number of genes (markers) necessary to reconstruct the Ulva species tree reconstructed with the 99 chloroplast and mitochondrial markers, Robinson-Foulds, Kuhner-Felsenstein, Maximum Agreement Subtree and correlation between the common nodes metrics were calculated between each of the 99 chloroplast and mitochondrial markers and the Ulva species tree reconstructed from supermatrix analysis.
The same approach applied to the Ulva species trees reconstructed using chloroplast and mitochondrial supermatrix and coalesce-based analyses suggested that Maximum Agreement Subtree and common correlation nodes metrics are the best performers to assess phylogenetic tree distances when the tree do not have the same set of tips. The 10 markers (6 chloroplasts and 4 mitochondrial) with the best MAST% and common correlation nodes scores were arbitrarily chosen as candidates for the subsequent combinatorial phylogenetic analyses.
Combinatorial phylogenetic analysis
For the combinatorial phylogenetic analysis, a custom python script was used to exhaustively calculate the permutations between the chosen 10 marker genes, sampling between 2 and 10 markers. This resulted in the 945 unique combinations of at least a chloroplast and a mitochondrial marker (24 combinations of 2 marker genes, 96 of 3 markers, 194 of 4 markers, 246 of 5 markers, 209 of 6 markers, 120 of 7 markers, 45 of 8 markers, 10 of 9 markers and finally 1 containing all 10 markers genes). For each combination of markers, the script would then independently reconstruct the corresponding phylogenetic tree by invoking IQtree, inferring the best model and rate of heterogeneity across sites, with 1,000 ultra-fast bootstrap and SH-aLRT branch test replicates.
Four metrics (RF, KF, MAST% and common correlation nodes scores) between each of the reconstructed 945 tree and the Ulva species tree reconstructed with the 99 chloroplast and mitochondrial markers were calculated in an iterative manner to identify the minimum set of chloroplast and mitochondrial markers necessary to reconstruct a ML phylogenetic tree concordant with the Ulva species tree reconstructed in this study. These markers are suggested to be used as a novel combination of markers to molecularly characterize Ulva species, and universal primers will be designed for each of the markers.







r each combination.

  genes	representative best genes markers	MAST%	# of equivalent combinations	Common node correlation	# of equivalent combinations
2	psaA_cox1
	0.824	1	0.901	1  psaA_cox2
3	rps2_psaA_cox1
	0.882	6	0.931	1 psbB_cox1_cox2
4	psbD_psaA_cox1_cox2	0.941	1	0.950	1
5	psbD_rps2_psaA_cox1_cox2	0.941	6	0.960	1 psaB_psbB_rps2_cox1_cox2
6	psbB_psbD_rps2_psaA_cox1_cox2	0.941
	10	0.960	1 petB_psaB_psbB_rps2_cox1_cox2
7	psaB_psbB_psbD_rps2_psaA_cox1_cox2	0.941	8	0.960	3 petB_psbD_rps2_psaA_atp6_cox1_cox2
8	petB_psbB_psbD_rps2_psaA_atp6_cox1_cox2	0.941	2	0.960	1
9	petB_psaB_psbB_psbD_rps2_psaA_atp6_cox1_rps3	0.922
	2	0.950	2
10	petB_psaB_psbB_psbD_rps2_psaA_atp6_cox1_cox2_rps3	0.882	1	0.931	1








## Lessons Learnt {#sec-lesson-learnt-markers-selection}

So far, we have learnt:







